<?php
/**
 * DocumentApi
 * PHP version 7.4
 *
 * @category Class
 * @package  BoldSign
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * BoldSign API
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1
 * Generated by: https://openapi-generator.tech
 * Generator version: 7.8.0
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace BoldSign\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\ConnectException;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use BoldSign\ApiException;
use BoldSign\Configuration;
use BoldSign\HeaderSelector;
use BoldSign\ObjectSerializer;

/**
 * DocumentApi Class Doc Comment
 *
 * @category Class
 * @package  BoldSign
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class DocumentApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @var int Host index
     */
    protected $hostIndex;

    /** @var string[] $contentTypes **/
    public const contentTypes = [
        'addAuthentication' => [
            'application/json;odata.metadata=minimal;odata.streaming=true',
            'application/json;odata.metadata=minimal;odata.streaming=false',
            'application/json;odata.metadata=minimal',
            'application/json;odata.metadata=full;odata.streaming=true',
            'application/json;odata.metadata=full;odata.streaming=false',
            'application/json;odata.metadata=full',
            'application/json;odata.metadata=none;odata.streaming=true',
            'application/json;odata.metadata=none;odata.streaming=false',
            'application/json;odata.metadata=none',
            'application/json;odata.streaming=true',
            'application/json;odata.streaming=false',
            'application/json',
            'application/xml',
            'application/prs.odatatestxx-odata',
            'application/json-patch+json',
            'text/json',
            'application/*+json',
        ],
        'addTag' => [
            'application/json;odata.metadata=minimal;odata.streaming=true',
            'application/json;odata.metadata=minimal;odata.streaming=false',
            'application/json;odata.metadata=minimal',
            'application/json;odata.metadata=full;odata.streaming=true',
            'application/json;odata.metadata=full;odata.streaming=false',
            'application/json;odata.metadata=full',
            'application/json;odata.metadata=none;odata.streaming=true',
            'application/json;odata.metadata=none;odata.streaming=false',
            'application/json;odata.metadata=none',
            'application/json;odata.streaming=true',
            'application/json;odata.streaming=false',
            'application/json',
            'application/xml',
            'application/prs.odatatestxx-odata',
            'application/json-patch+json',
            'text/json',
            'application/*+json',
        ],
        'behalfDocuments' => [
            'application/json',
        ],
        'changeAccessCode' => [
            'application/json;odata.metadata=minimal;odata.streaming=true',
            'application/json;odata.metadata=minimal;odata.streaming=false',
            'application/json;odata.metadata=minimal',
            'application/json;odata.metadata=full;odata.streaming=true',
            'application/json;odata.metadata=full;odata.streaming=false',
            'application/json;odata.metadata=full',
            'application/json;odata.metadata=none;odata.streaming=true',
            'application/json;odata.metadata=none;odata.streaming=false',
            'application/json;odata.metadata=none',
            'application/json;odata.streaming=true',
            'application/json;odata.streaming=false',
            'application/json',
            'application/xml',
            'application/prs.odatatestxx-odata',
            'application/json-patch+json',
            'text/json',
            'application/*+json',
        ],
        'changeRecipient' => [
            'application/json;odata.metadata=minimal;odata.streaming=true',
            'application/json;odata.metadata=minimal;odata.streaming=false',
            'application/json;odata.metadata=minimal',
            'application/json;odata.metadata=full;odata.streaming=true',
            'application/json;odata.metadata=full;odata.streaming=false',
            'application/json;odata.metadata=full',
            'application/json;odata.metadata=none;odata.streaming=true',
            'application/json;odata.metadata=none;odata.streaming=false',
            'application/json;odata.metadata=none',
            'application/json;odata.streaming=true',
            'application/json;odata.streaming=false',
            'application/json',
            'application/xml',
            'application/prs.odatatestxx-odata',
            'application/json-patch+json',
            'text/json',
            'application/*+json',
        ],
        'createEmbeddedRequestUrlDocument' => [
            'application/json',
            'multipart/form-data',
            'application/x-www-form-urlencoded',
        ],
        'deleteDocument' => [
            'application/json',
        ],
        'deleteTag' => [
            'application/json;odata.metadata=minimal;odata.streaming=true',
            'application/json;odata.metadata=minimal;odata.streaming=false',
            'application/json;odata.metadata=minimal',
            'application/json;odata.metadata=full;odata.streaming=true',
            'application/json;odata.metadata=full;odata.streaming=false',
            'application/json;odata.metadata=full',
            'application/json;odata.metadata=none;odata.streaming=true',
            'application/json;odata.metadata=none;odata.streaming=false',
            'application/json;odata.metadata=none',
            'application/json;odata.streaming=true',
            'application/json;odata.streaming=false',
            'application/json',
            'application/xml',
            'application/prs.odatatestxx-odata',
            'application/json-patch+json',
            'text/json',
            'application/*+json',
        ],
        'downloadAttachment' => [
            'application/json',
        ],
        'downloadAuditLog' => [
            'application/json',
        ],
        'downloadDocument' => [
            'application/json',
        ],
        'extendExpiry' => [
            'application/json;odata.metadata=minimal;odata.streaming=true',
            'application/json;odata.metadata=minimal;odata.streaming=false',
            'application/json;odata.metadata=minimal',
            'application/json;odata.metadata=full;odata.streaming=true',
            'application/json;odata.metadata=full;odata.streaming=false',
            'application/json;odata.metadata=full',
            'application/json;odata.metadata=none;odata.streaming=true',
            'application/json;odata.metadata=none;odata.streaming=false',
            'application/json;odata.metadata=none',
            'application/json;odata.streaming=true',
            'application/json;odata.streaming=false',
            'application/json',
            'application/xml',
            'application/prs.odatatestxx-odata',
            'application/json-patch+json',
            'text/json',
            'application/*+json',
        ],
        'getEmbeddedSignLink' => [
            'application/json',
        ],
        'getProperties' => [
            'application/json',
        ],
        'listDocuments' => [
            'application/json',
        ],
        'prefillFields' => [
            'application/json;odata.metadata=minimal;odata.streaming=true',
            'application/json;odata.metadata=minimal;odata.streaming=false',
            'application/json;odata.metadata=minimal',
            'application/json;odata.metadata=full;odata.streaming=true',
            'application/json;odata.metadata=full;odata.streaming=false',
            'application/json;odata.metadata=full',
            'application/json;odata.metadata=none;odata.streaming=true',
            'application/json;odata.metadata=none;odata.streaming=false',
            'application/json;odata.metadata=none',
            'application/json;odata.streaming=true',
            'application/json;odata.streaming=false',
            'application/json',
            'application/xml',
            'application/prs.odatatestxx-odata',
            'application/json-patch+json',
            'text/json',
            'application/*+json',
        ],
        'remindDocument' => [
            'application/json;odata.metadata=minimal;odata.streaming=true',
            'application/json;odata.metadata=minimal;odata.streaming=false',
            'application/json;odata.metadata=minimal',
            'application/json;odata.metadata=full;odata.streaming=true',
            'application/json;odata.metadata=full;odata.streaming=false',
            'application/json;odata.metadata=full',
            'application/json;odata.metadata=none;odata.streaming=true',
            'application/json;odata.metadata=none;odata.streaming=false',
            'application/json;odata.metadata=none',
            'application/json;odata.streaming=true',
            'application/json;odata.streaming=false',
            'application/json',
            'application/xml',
            'application/prs.odatatestxx-odata',
            'application/json-patch+json',
            'text/json',
            'application/*+json',
        ],
        'removeAuthentication' => [
            'application/json;odata.metadata=minimal;odata.streaming=true',
            'application/json;odata.metadata=minimal;odata.streaming=false',
            'application/json;odata.metadata=minimal',
            'application/json;odata.metadata=full;odata.streaming=true',
            'application/json;odata.metadata=full;odata.streaming=false',
            'application/json;odata.metadata=full',
            'application/json;odata.metadata=none;odata.streaming=true',
            'application/json;odata.metadata=none;odata.streaming=false',
            'application/json;odata.metadata=none',
            'application/json;odata.streaming=true',
            'application/json;odata.streaming=false',
            'application/json',
            'application/xml',
            'application/prs.odatatestxx-odata',
            'application/json-patch+json',
            'text/json',
            'application/*+json',
        ],
        'revokeDocument' => [
            'application/json;odata.metadata=minimal;odata.streaming=true',
            'application/json;odata.metadata=minimal;odata.streaming=false',
            'application/json;odata.metadata=minimal',
            'application/json;odata.metadata=full;odata.streaming=true',
            'application/json;odata.metadata=full;odata.streaming=false',
            'application/json;odata.metadata=full',
            'application/json;odata.metadata=none;odata.streaming=true',
            'application/json;odata.metadata=none;odata.streaming=false',
            'application/json;odata.metadata=none',
            'application/json;odata.streaming=true',
            'application/json;odata.streaming=false',
            'application/json',
            'application/xml',
            'application/prs.odatatestxx-odata',
            'application/json-patch+json',
            'text/json',
            'application/*+json',
        ],
        'sendDocument' => [
            'application/json',
            'multipart/form-data',
            'application/x-www-form-urlencoded',
        ],
        'teamDocuments' => [
            'application/json',
        ],
    ];

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     * @param int             $hostIndex (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        Configuration $config = null,
        ClientInterface $client = null,
        HeaderSelector $selector = null,
        $hostIndex = 0
    ) {
        $this->config = $config ?: new Configuration();
        $this->client = $client ?: new Client();
        $this->headerSelector = $selector ?: new HeaderSelector();
        $this->hostIndex = $hostIndex;
    }

    /**
     * Set the host index
     *
     * @param int $hostIndex Host index (required)
     */
    public function setHostIndex($hostIndex): void
    {
        $this->hostIndex = $hostIndex;
    }

    /**
     * Get the host index
     *
     * @return int Host index
     */
    public function getHostIndex()
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation addAuthentication
     *
     * The add authentication to recipient.
     *
     * @param  string $document_id The DocumentId. (required)
     * @param  \BoldSign\Model\AccessCodeDetail $access_code_detail Access code details. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['addAuthentication'] to see the possible values for this operation
     *
     * @throws \BoldSign\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function addAuthentication($document_id, $access_code_detail = null, string $contentType = self::contentTypes['addAuthentication'][0])
    {
        $this->addAuthenticationWithHttpInfo($document_id, $access_code_detail, $contentType);
    }

    /**
     * Operation addAuthenticationWithHttpInfo
     *
     * The add authentication to recipient.
     *
     * @param  string $document_id The DocumentId. (required)
     * @param  \BoldSign\Model\AccessCodeDetail $access_code_detail Access code details. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['addAuthentication'] to see the possible values for this operation
     *
     * @throws \BoldSign\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function addAuthenticationWithHttpInfo($document_id, $access_code_detail = null, string $contentType = self::contentTypes['addAuthentication'][0])
    {
        $request = $this->addAuthenticationRequest($document_id, $access_code_detail, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BoldSign\Model\ErrorResult',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BoldSign\Model\ErrorResult',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation addAuthenticationAsync
     *
     * The add authentication to recipient.
     *
     * @param  string $document_id The DocumentId. (required)
     * @param  \BoldSign\Model\AccessCodeDetail $access_code_detail Access code details. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['addAuthentication'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function addAuthenticationAsync($document_id, $access_code_detail = null, string $contentType = self::contentTypes['addAuthentication'][0])
    {
        return $this->addAuthenticationAsyncWithHttpInfo($document_id, $access_code_detail, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation addAuthenticationAsyncWithHttpInfo
     *
     * The add authentication to recipient.
     *
     * @param  string $document_id The DocumentId. (required)
     * @param  \BoldSign\Model\AccessCodeDetail $access_code_detail Access code details. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['addAuthentication'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function addAuthenticationAsyncWithHttpInfo($document_id, $access_code_detail = null, string $contentType = self::contentTypes['addAuthentication'][0])
    {
        $returnType = '';
        $request = $this->addAuthenticationRequest($document_id, $access_code_detail, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'addAuthentication'
     *
     * @param  string $document_id The DocumentId. (required)
     * @param  \BoldSign\Model\AccessCodeDetail $access_code_detail Access code details. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['addAuthentication'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function addAuthenticationRequest($document_id, $access_code_detail = null, string $contentType = self::contentTypes['addAuthentication'][0])
    {

        // verify the required parameter 'document_id' is set
        if ($document_id === null || (is_array($document_id) && count($document_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $document_id when calling addAuthentication'
            );
        }



        $resourcePath = '/v1/document/addAuthentication';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        if(!is_array($access_code_detail)) {
            $formParams = ObjectSerializer::getFormParams(
                $access_code_detail
            );
        }
        else {
            foreach($access_code_detail as $param){
                $formParams = ObjectSerializer::getFormParams(
                $param);
            }
        }

        $multipart = !empty($formParams);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $document_id,
            'documentId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            $multipart ? ['multipart/form-data'] : ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) === 0) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($access_code_detail));
            } else {
                $httpBody = $access_code_detail;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                if (!empty($body)) {
                    $multipartContents[] = [
                        'name'     => 'body',
                        'contents' => $body,
                        'headers'  => ['Content-Type' => 'application/json'],
                    ];
                }

                if ($payloadHook = $this->config->getPayloadHook()) {
                    $payloadHook('multipart', $multipartContents, $access_code_detail);
                }
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-KEY');
        if ($apiKey !== null) {
            $headers['X-API-KEY'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PATCH',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation addTag
     *
     * Add the Tags in Documents.
     *
     * @param  \BoldSign\Model\DocumentTags $document_tags Contains DocumentId and LabelNames for Adding Tags. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['addTag'] to see the possible values for this operation
     *
     * @throws \BoldSign\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function addTag($document_tags = null, string $contentType = self::contentTypes['addTag'][0])
    {
        $this->addTagWithHttpInfo($document_tags, $contentType);
    }

    /**
     * Operation addTagWithHttpInfo
     *
     * Add the Tags in Documents.
     *
     * @param  \BoldSign\Model\DocumentTags $document_tags Contains DocumentId and LabelNames for Adding Tags. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['addTag'] to see the possible values for this operation
     *
     * @throws \BoldSign\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function addTagWithHttpInfo($document_tags = null, string $contentType = self::contentTypes['addTag'][0])
    {
        $request = $this->addTagRequest($document_tags, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BoldSign\Model\ErrorResult',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BoldSign\Model\ErrorResult',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation addTagAsync
     *
     * Add the Tags in Documents.
     *
     * @param  \BoldSign\Model\DocumentTags $document_tags Contains DocumentId and LabelNames for Adding Tags. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['addTag'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function addTagAsync($document_tags = null, string $contentType = self::contentTypes['addTag'][0])
    {
        return $this->addTagAsyncWithHttpInfo($document_tags, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation addTagAsyncWithHttpInfo
     *
     * Add the Tags in Documents.
     *
     * @param  \BoldSign\Model\DocumentTags $document_tags Contains DocumentId and LabelNames for Adding Tags. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['addTag'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function addTagAsyncWithHttpInfo($document_tags = null, string $contentType = self::contentTypes['addTag'][0])
    {
        $returnType = '';
        $request = $this->addTagRequest($document_tags, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'addTag'
     *
     * @param  \BoldSign\Model\DocumentTags $document_tags Contains DocumentId and LabelNames for Adding Tags. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['addTag'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function addTagRequest($document_tags = null, string $contentType = self::contentTypes['addTag'][0])
    {



        $resourcePath = '/v1/document/addTags';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        if(!is_array($document_tags)) {
            $formParams = ObjectSerializer::getFormParams(
                $document_tags
            );
        }
        else {
            foreach($document_tags as $param){
                $formParams = ObjectSerializer::getFormParams(
                $param);
            }
        }

        $multipart = !empty($formParams);




        $headers = $this->headerSelector->selectHeaders(
            $multipart ? ['multipart/form-data'] : ['application/json;odata.metadata=minimal;odata.streaming=true', 'application/json;odata.metadata=minimal;odata.streaming=false', 'application/json;odata.metadata=minimal', 'application/json;odata.metadata=full;odata.streaming=true', 'application/json;odata.metadata=full;odata.streaming=false', 'application/json;odata.metadata=full', 'application/json;odata.metadata=none;odata.streaming=true', 'application/json;odata.metadata=none;odata.streaming=false', 'application/json;odata.metadata=none', 'application/json;odata.streaming=true', 'application/json;odata.streaming=false', 'application/json', 'application/xml', 'application/prs.odatatestxx-odata', 'text/plain', 'text/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) === 0) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($document_tags));
            } else {
                $httpBody = $document_tags;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                if (!empty($body)) {
                    $multipartContents[] = [
                        'name'     => 'body',
                        'contents' => $body,
                        'headers'  => ['Content-Type' => 'application/json'],
                    ];
                }

                if ($payloadHook = $this->config->getPayloadHook()) {
                    $payloadHook('multipart', $multipartContents, $document_tags);
                }
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-KEY');
        if ($apiKey !== null) {
            $headers['X-API-KEY'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PATCH',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation behalfDocuments
     *
     * Gets the behalf documents.
     *
     * @param  int $page Page index specified in get document list request. (required)
     * @param  string $page_type The filter used to differentiate between documents sent on the user&#39;s behalf and documents sent by the user on behalf of others. The API will return documents based on the specified value. (optional)
     * @param  string[] $email_address The sender identity&#39;s email used to filter the documents returned in the API. The API will return documents that were sent on behalf of the specified email address. (optional)
     * @param  string[] $signers A list of signer email addresses used to filter the documents returned in the API. The API will return documents where the signer&#39;s email address matches one of the email addresses provided in this list (optional)
     * @param  int $page_size Page size specified in get document list request. (optional, default to 10)
     * @param  \DateTime $start_date Start date of the document (optional)
     * @param  string[] $status Status of the document such as In-progress, Completed, Decline, Expired, Revoked, Draft. (optional)
     * @param  \DateTime $end_date End date of the document (optional)
     * @param  string $search_key Documents can be listed by the search key present in the document like document title, document ID, sender or recipient(s) name, etc., (optional)
     * @param  string[] $labels Labels of the document. (optional)
     * @param  int $next_cursor Next cursor value for pagination, required for fetching the next set of documents beyond 10,000 records. (optional)
     * @param  string[] $brand_ids BrandId(s) of the document. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['behalfDocuments'] to see the possible values for this operation
     *
     * @throws \BoldSign\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \BoldSign\Model\BehalfDocumentRecords|\BoldSign\Model\ErrorResult|\BoldSign\Model\ErrorResult
     */
    public function behalfDocuments($page, $page_type = null, $email_address = null, $signers = null, $page_size = 10, $start_date = null, $status = null, $end_date = null, $search_key = null, $labels = null, $next_cursor = null, $brand_ids = null, string $contentType = self::contentTypes['behalfDocuments'][0])
    {
        list($response) = $this->behalfDocumentsWithHttpInfo($page, $page_type, $email_address, $signers, $page_size, $start_date, $status, $end_date, $search_key, $labels, $next_cursor, $brand_ids, $contentType);
        return $response;
    }

    /**
     * Operation behalfDocumentsWithHttpInfo
     *
     * Gets the behalf documents.
     *
     * @param  int $page Page index specified in get document list request. (required)
     * @param  string $page_type The filter used to differentiate between documents sent on the user&#39;s behalf and documents sent by the user on behalf of others. The API will return documents based on the specified value. (optional)
     * @param  string[] $email_address The sender identity&#39;s email used to filter the documents returned in the API. The API will return documents that were sent on behalf of the specified email address. (optional)
     * @param  string[] $signers A list of signer email addresses used to filter the documents returned in the API. The API will return documents where the signer&#39;s email address matches one of the email addresses provided in this list (optional)
     * @param  int $page_size Page size specified in get document list request. (optional, default to 10)
     * @param  \DateTime $start_date Start date of the document (optional)
     * @param  string[] $status Status of the document such as In-progress, Completed, Decline, Expired, Revoked, Draft. (optional)
     * @param  \DateTime $end_date End date of the document (optional)
     * @param  string $search_key Documents can be listed by the search key present in the document like document title, document ID, sender or recipient(s) name, etc., (optional)
     * @param  string[] $labels Labels of the document. (optional)
     * @param  int $next_cursor Next cursor value for pagination, required for fetching the next set of documents beyond 10,000 records. (optional)
     * @param  string[] $brand_ids BrandId(s) of the document. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['behalfDocuments'] to see the possible values for this operation
     *
     * @throws \BoldSign\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \BoldSign\Model\BehalfDocumentRecords|\BoldSign\Model\ErrorResult|\BoldSign\Model\ErrorResult, HTTP status code, HTTP response headers (array of strings)
     */
    public function behalfDocumentsWithHttpInfo($page, $page_type = null, $email_address = null, $signers = null, $page_size = 10, $start_date = null, $status = null, $end_date = null, $search_key = null, $labels = null, $next_cursor = null, $brand_ids = null, string $contentType = self::contentTypes['behalfDocuments'][0])
    {
        $request = $this->behalfDocumentsRequest($page, $page_type, $email_address, $signers, $page_size, $start_date, $status, $end_date, $search_key, $labels, $next_cursor, $brand_ids, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\BoldSign\Model\BehalfDocumentRecords' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\BoldSign\Model\BehalfDocumentRecords' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\BoldSign\Model\BehalfDocumentRecords', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 401:
                    if ('\BoldSign\Model\ErrorResult' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\BoldSign\Model\ErrorResult' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\BoldSign\Model\ErrorResult', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 403:
                    if ('\BoldSign\Model\ErrorResult' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\BoldSign\Model\ErrorResult' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\BoldSign\Model\ErrorResult', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\BoldSign\Model\BehalfDocumentRecords';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BoldSign\Model\BehalfDocumentRecords',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BoldSign\Model\ErrorResult',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BoldSign\Model\ErrorResult',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation behalfDocumentsAsync
     *
     * Gets the behalf documents.
     *
     * @param  int $page Page index specified in get document list request. (required)
     * @param  string $page_type The filter used to differentiate between documents sent on the user&#39;s behalf and documents sent by the user on behalf of others. The API will return documents based on the specified value. (optional)
     * @param  string[] $email_address The sender identity&#39;s email used to filter the documents returned in the API. The API will return documents that were sent on behalf of the specified email address. (optional)
     * @param  string[] $signers A list of signer email addresses used to filter the documents returned in the API. The API will return documents where the signer&#39;s email address matches one of the email addresses provided in this list (optional)
     * @param  int $page_size Page size specified in get document list request. (optional, default to 10)
     * @param  \DateTime $start_date Start date of the document (optional)
     * @param  string[] $status Status of the document such as In-progress, Completed, Decline, Expired, Revoked, Draft. (optional)
     * @param  \DateTime $end_date End date of the document (optional)
     * @param  string $search_key Documents can be listed by the search key present in the document like document title, document ID, sender or recipient(s) name, etc., (optional)
     * @param  string[] $labels Labels of the document. (optional)
     * @param  int $next_cursor Next cursor value for pagination, required for fetching the next set of documents beyond 10,000 records. (optional)
     * @param  string[] $brand_ids BrandId(s) of the document. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['behalfDocuments'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function behalfDocumentsAsync($page, $page_type = null, $email_address = null, $signers = null, $page_size = 10, $start_date = null, $status = null, $end_date = null, $search_key = null, $labels = null, $next_cursor = null, $brand_ids = null, string $contentType = self::contentTypes['behalfDocuments'][0])
    {
        return $this->behalfDocumentsAsyncWithHttpInfo($page, $page_type, $email_address, $signers, $page_size, $start_date, $status, $end_date, $search_key, $labels, $next_cursor, $brand_ids, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation behalfDocumentsAsyncWithHttpInfo
     *
     * Gets the behalf documents.
     *
     * @param  int $page Page index specified in get document list request. (required)
     * @param  string $page_type The filter used to differentiate between documents sent on the user&#39;s behalf and documents sent by the user on behalf of others. The API will return documents based on the specified value. (optional)
     * @param  string[] $email_address The sender identity&#39;s email used to filter the documents returned in the API. The API will return documents that were sent on behalf of the specified email address. (optional)
     * @param  string[] $signers A list of signer email addresses used to filter the documents returned in the API. The API will return documents where the signer&#39;s email address matches one of the email addresses provided in this list (optional)
     * @param  int $page_size Page size specified in get document list request. (optional, default to 10)
     * @param  \DateTime $start_date Start date of the document (optional)
     * @param  string[] $status Status of the document such as In-progress, Completed, Decline, Expired, Revoked, Draft. (optional)
     * @param  \DateTime $end_date End date of the document (optional)
     * @param  string $search_key Documents can be listed by the search key present in the document like document title, document ID, sender or recipient(s) name, etc., (optional)
     * @param  string[] $labels Labels of the document. (optional)
     * @param  int $next_cursor Next cursor value for pagination, required for fetching the next set of documents beyond 10,000 records. (optional)
     * @param  string[] $brand_ids BrandId(s) of the document. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['behalfDocuments'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function behalfDocumentsAsyncWithHttpInfo($page, $page_type = null, $email_address = null, $signers = null, $page_size = 10, $start_date = null, $status = null, $end_date = null, $search_key = null, $labels = null, $next_cursor = null, $brand_ids = null, string $contentType = self::contentTypes['behalfDocuments'][0])
    {
        $returnType = '\BoldSign\Model\BehalfDocumentRecords';
        $request = $this->behalfDocumentsRequest($page, $page_type, $email_address, $signers, $page_size, $start_date, $status, $end_date, $search_key, $labels, $next_cursor, $brand_ids, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'behalfDocuments'
     *
     * @param  int $page Page index specified in get document list request. (required)
     * @param  string $page_type The filter used to differentiate between documents sent on the user&#39;s behalf and documents sent by the user on behalf of others. The API will return documents based on the specified value. (optional)
     * @param  string[] $email_address The sender identity&#39;s email used to filter the documents returned in the API. The API will return documents that were sent on behalf of the specified email address. (optional)
     * @param  string[] $signers A list of signer email addresses used to filter the documents returned in the API. The API will return documents where the signer&#39;s email address matches one of the email addresses provided in this list (optional)
     * @param  int $page_size Page size specified in get document list request. (optional, default to 10)
     * @param  \DateTime $start_date Start date of the document (optional)
     * @param  string[] $status Status of the document such as In-progress, Completed, Decline, Expired, Revoked, Draft. (optional)
     * @param  \DateTime $end_date End date of the document (optional)
     * @param  string $search_key Documents can be listed by the search key present in the document like document title, document ID, sender or recipient(s) name, etc., (optional)
     * @param  string[] $labels Labels of the document. (optional)
     * @param  int $next_cursor Next cursor value for pagination, required for fetching the next set of documents beyond 10,000 records. (optional)
     * @param  string[] $brand_ids BrandId(s) of the document. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['behalfDocuments'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function behalfDocumentsRequest($page, $page_type = null, $email_address = null, $signers = null, $page_size = 10, $start_date = null, $status = null, $end_date = null, $search_key = null, $labels = null, $next_cursor = null, $brand_ids = null, string $contentType = self::contentTypes['behalfDocuments'][0])
    {

        // verify the required parameter 'page' is set
        if ($page === null || (is_array($page) && count($page) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $page when calling behalfDocuments'
            );
        }













        $resourcePath = '/v1/document/behalfList';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page_type,
            'PageType', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $email_address,
            'EmailAddress', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $signers,
            'Signers', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page_size,
            'PageSize', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page,
            'Page', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $start_date,
            'StartDate', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $status,
            'Status', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $end_date,
            'EndDate', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $search_key,
            'SearchKey', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $labels,
            'Labels', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $next_cursor,
            'NextCursor', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $brand_ids,
            'BrandIds', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            $multipart ? ['multipart/form-data'] : ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                if (!empty($body)) {
                    $multipartContents[] = [
                        'name'     => 'body',
                        'contents' => $body,
                        'headers'  => ['Content-Type' => 'application/json'],
                    ];
                }

                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-KEY');
        if ($apiKey !== null) {
            $headers['X-API-KEY'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation changeAccessCode
     *
     * Changes the access code for the given document signer.
     *
     * @param  string $document_id document_id (required)
     * @param  \BoldSign\Model\AccessCodeDetails $access_code_details The new access code. (required)
     * @param  string $email_id email_id (optional)
     * @param  int $z_order z_order (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['changeAccessCode'] to see the possible values for this operation
     *
     * @throws \BoldSign\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function changeAccessCode($document_id, $access_code_details, $email_id = null, $z_order = null, string $contentType = self::contentTypes['changeAccessCode'][0])
    {
        $this->changeAccessCodeWithHttpInfo($document_id, $access_code_details, $email_id, $z_order, $contentType);
    }

    /**
     * Operation changeAccessCodeWithHttpInfo
     *
     * Changes the access code for the given document signer.
     *
     * @param  string $document_id (required)
     * @param  \BoldSign\Model\AccessCodeDetails $access_code_details The new access code. (required)
     * @param  string $email_id (optional)
     * @param  int $z_order (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['changeAccessCode'] to see the possible values for this operation
     *
     * @throws \BoldSign\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function changeAccessCodeWithHttpInfo($document_id, $access_code_details, $email_id = null, $z_order = null, string $contentType = self::contentTypes['changeAccessCode'][0])
    {
        $request = $this->changeAccessCodeRequest($document_id, $access_code_details, $email_id, $z_order, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BoldSign\Model\ErrorResult',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BoldSign\Model\ErrorResult',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation changeAccessCodeAsync
     *
     * Changes the access code for the given document signer.
     *
     * @param  string $document_id (required)
     * @param  \BoldSign\Model\AccessCodeDetails $access_code_details The new access code. (required)
     * @param  string $email_id (optional)
     * @param  int $z_order (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['changeAccessCode'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function changeAccessCodeAsync($document_id, $access_code_details, $email_id = null, $z_order = null, string $contentType = self::contentTypes['changeAccessCode'][0])
    {
        return $this->changeAccessCodeAsyncWithHttpInfo($document_id, $access_code_details, $email_id, $z_order, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation changeAccessCodeAsyncWithHttpInfo
     *
     * Changes the access code for the given document signer.
     *
     * @param  string $document_id (required)
     * @param  \BoldSign\Model\AccessCodeDetails $access_code_details The new access code. (required)
     * @param  string $email_id (optional)
     * @param  int $z_order (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['changeAccessCode'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function changeAccessCodeAsyncWithHttpInfo($document_id, $access_code_details, $email_id = null, $z_order = null, string $contentType = self::contentTypes['changeAccessCode'][0])
    {
        $returnType = '';
        $request = $this->changeAccessCodeRequest($document_id, $access_code_details, $email_id, $z_order, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'changeAccessCode'
     *
     * @param  string $document_id (required)
     * @param  \BoldSign\Model\AccessCodeDetails $access_code_details The new access code. (required)
     * @param  string $email_id (optional)
     * @param  int $z_order (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['changeAccessCode'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function changeAccessCodeRequest($document_id, $access_code_details, $email_id = null, $z_order = null, string $contentType = self::contentTypes['changeAccessCode'][0])
    {

        // verify the required parameter 'document_id' is set
        if ($document_id === null || (is_array($document_id) && count($document_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $document_id when calling changeAccessCode'
            );
        }

        // verify the required parameter 'access_code_details' is set
        if ($access_code_details === null || (is_array($access_code_details) && count($access_code_details) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $access_code_details when calling changeAccessCode'
            );
        }




        $resourcePath = '/v1/document/changeAccessCode';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        if(!is_array($access_code_details)) {
            $formParams = ObjectSerializer::getFormParams(
                $access_code_details
            );
        }
        else {
            foreach($access_code_details as $param){
                $formParams = ObjectSerializer::getFormParams(
                $param);
            }
        }

        $multipart = !empty($formParams);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $document_id,
            'DocumentId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $email_id,
            'EmailId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $z_order,
            'ZOrder', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            $multipart ? ['multipart/form-data'] : ['application/json;odata.metadata=minimal;odata.streaming=true', 'application/json;odata.metadata=minimal;odata.streaming=false', 'application/json;odata.metadata=minimal', 'application/json;odata.metadata=full;odata.streaming=true', 'application/json;odata.metadata=full;odata.streaming=false', 'application/json;odata.metadata=full', 'application/json;odata.metadata=none;odata.streaming=true', 'application/json;odata.metadata=none;odata.streaming=false', 'application/json;odata.metadata=none', 'application/json;odata.streaming=true', 'application/json;odata.streaming=false', 'application/json', 'application/xml', 'application/prs.odatatestxx-odata', 'text/plain', 'text/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) === 0) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($access_code_details));
            } else {
                $httpBody = $access_code_details;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                if (!empty($body)) {
                    $multipartContents[] = [
                        'name'     => 'body',
                        'contents' => $body,
                        'headers'  => ['Content-Type' => 'application/json'],
                    ];
                }

                if ($payloadHook = $this->config->getPayloadHook()) {
                    $payloadHook('multipart', $multipartContents, $access_code_details);
                }
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-KEY');
        if ($apiKey !== null) {
            $headers['X-API-KEY'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PATCH',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation changeRecipient
     *
     * Change recipient details of a document.
     *
     * @param  string $document_id The documentID details. (required)
     * @param  \BoldSign\Model\ChangeRecipient $change_recipient The new recipient details. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['changeRecipient'] to see the possible values for this operation
     *
     * @throws \BoldSign\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \BoldSign\Model\ErrorResult|\BoldSign\Model\ErrorResult
     */
    public function changeRecipient($document_id, $change_recipient, string $contentType = self::contentTypes['changeRecipient'][0])
    {
        list($response) = $this->changeRecipientWithHttpInfo($document_id, $change_recipient, $contentType);
        return $response;
    }

    /**
     * Operation changeRecipientWithHttpInfo
     *
     * Change recipient details of a document.
     *
     * @param  string $document_id The documentID details. (required)
     * @param  \BoldSign\Model\ChangeRecipient $change_recipient The new recipient details. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['changeRecipient'] to see the possible values for this operation
     *
     * @throws \BoldSign\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \BoldSign\Model\ErrorResult|\BoldSign\Model\ErrorResult, HTTP status code, HTTP response headers (array of strings)
     */
    public function changeRecipientWithHttpInfo($document_id, $change_recipient, string $contentType = self::contentTypes['changeRecipient'][0])
    {
        $request = $this->changeRecipientRequest($document_id, $change_recipient, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 401:
                    if ('\BoldSign\Model\ErrorResult' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\BoldSign\Model\ErrorResult' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\BoldSign\Model\ErrorResult', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 200:
                    if ('\BoldSign\Model\ErrorResult' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\BoldSign\Model\ErrorResult' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\BoldSign\Model\ErrorResult', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\BoldSign\Model\ErrorResult';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BoldSign\Model\ErrorResult',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BoldSign\Model\ErrorResult',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation changeRecipientAsync
     *
     * Change recipient details of a document.
     *
     * @param  string $document_id The documentID details. (required)
     * @param  \BoldSign\Model\ChangeRecipient $change_recipient The new recipient details. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['changeRecipient'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function changeRecipientAsync($document_id, $change_recipient, string $contentType = self::contentTypes['changeRecipient'][0])
    {
        return $this->changeRecipientAsyncWithHttpInfo($document_id, $change_recipient, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation changeRecipientAsyncWithHttpInfo
     *
     * Change recipient details of a document.
     *
     * @param  string $document_id The documentID details. (required)
     * @param  \BoldSign\Model\ChangeRecipient $change_recipient The new recipient details. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['changeRecipient'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function changeRecipientAsyncWithHttpInfo($document_id, $change_recipient, string $contentType = self::contentTypes['changeRecipient'][0])
    {
        $returnType = '\BoldSign\Model\ErrorResult';
        $request = $this->changeRecipientRequest($document_id, $change_recipient, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'changeRecipient'
     *
     * @param  string $document_id The documentID details. (required)
     * @param  \BoldSign\Model\ChangeRecipient $change_recipient The new recipient details. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['changeRecipient'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function changeRecipientRequest($document_id, $change_recipient, string $contentType = self::contentTypes['changeRecipient'][0])
    {

        // verify the required parameter 'document_id' is set
        if ($document_id === null || (is_array($document_id) && count($document_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $document_id when calling changeRecipient'
            );
        }

        // verify the required parameter 'change_recipient' is set
        if ($change_recipient === null || (is_array($change_recipient) && count($change_recipient) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $change_recipient when calling changeRecipient'
            );
        }


        $resourcePath = '/v1/document/changeRecipient';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        if(!is_array($change_recipient)) {
            $formParams = ObjectSerializer::getFormParams(
                $change_recipient
            );
        }
        else {
            foreach($change_recipient as $param){
                $formParams = ObjectSerializer::getFormParams(
                $param);
            }
        }

        $multipart = !empty($formParams);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $document_id,
            'documentId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            $multipart ? ['multipart/form-data'] : ['application/json;odata.metadata=minimal;odata.streaming=true', 'application/json;odata.metadata=minimal;odata.streaming=false', 'application/json;odata.metadata=minimal', 'application/json;odata.metadata=full;odata.streaming=true', 'application/json;odata.metadata=full;odata.streaming=false', 'application/json;odata.metadata=full', 'application/json;odata.metadata=none;odata.streaming=true', 'application/json;odata.metadata=none;odata.streaming=false', 'application/json;odata.metadata=none', 'application/json;odata.streaming=true', 'application/json;odata.streaming=false', 'application/json', 'application/xml', 'application/prs.odatatestxx-odata', 'text/plain', 'text/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) === 0) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($change_recipient));
            } else {
                $httpBody = $change_recipient;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                if (!empty($body)) {
                    $multipartContents[] = [
                        'name'     => 'body',
                        'contents' => $body,
                        'headers'  => ['Content-Type' => 'application/json'],
                    ];
                }

                if ($payloadHook = $this->config->getPayloadHook()) {
                    $payloadHook('multipart', $multipartContents, $change_recipient);
                }
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-KEY');
        if ($apiKey !== null) {
            $headers['X-API-KEY'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PATCH',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createEmbeddedRequestUrlDocument
     *
     * Generates a send URL which embeds document sending process into your application.
     *
     * @param  \BoldSign\Model\EmbeddedDocumentRequest $embedded_document_request The embedded send document request body. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createEmbeddedRequestUrlDocument'] to see the possible values for this operation
     *
     * @throws \BoldSign\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \BoldSign\Model\EmbeddedSendCreated|\BoldSign\Model\ErrorResult|\BoldSign\Model\ErrorResult
     */
    public function createEmbeddedRequestUrlDocument($embedded_document_request = null, string $contentType = self::contentTypes['createEmbeddedRequestUrlDocument'][0])
    {
        list($response) = $this->createEmbeddedRequestUrlDocumentWithHttpInfo($embedded_document_request, $contentType);
        return $response;
    }

    /**
     * Operation createEmbeddedRequestUrlDocumentWithHttpInfo
     *
     * Generates a send URL which embeds document sending process into your application.
     *
     * @param  \BoldSign\Model\EmbeddedDocumentRequest $embedded_document_request The embedded send document request body. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createEmbeddedRequestUrlDocument'] to see the possible values for this operation
     *
     * @throws \BoldSign\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \BoldSign\Model\EmbeddedSendCreated|\BoldSign\Model\ErrorResult|\BoldSign\Model\ErrorResult, HTTP status code, HTTP response headers (array of strings)
     */
    public function createEmbeddedRequestUrlDocumentWithHttpInfo($embedded_document_request = null, string $contentType = self::contentTypes['createEmbeddedRequestUrlDocument'][0])
    {
        $request = $this->createEmbeddedRequestUrlDocumentRequest($embedded_document_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 201:
                    if ('\BoldSign\Model\EmbeddedSendCreated' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\BoldSign\Model\EmbeddedSendCreated' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\BoldSign\Model\EmbeddedSendCreated', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 401:
                    if ('\BoldSign\Model\ErrorResult' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\BoldSign\Model\ErrorResult' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\BoldSign\Model\ErrorResult', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 403:
                    if ('\BoldSign\Model\ErrorResult' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\BoldSign\Model\ErrorResult' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\BoldSign\Model\ErrorResult', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\BoldSign\Model\EmbeddedSendCreated';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BoldSign\Model\EmbeddedSendCreated',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BoldSign\Model\ErrorResult',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BoldSign\Model\ErrorResult',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createEmbeddedRequestUrlDocumentAsync
     *
     * Generates a send URL which embeds document sending process into your application.
     *
     * @param  \BoldSign\Model\EmbeddedDocumentRequest $embedded_document_request The embedded send document request body. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createEmbeddedRequestUrlDocument'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createEmbeddedRequestUrlDocumentAsync($embedded_document_request = null, string $contentType = self::contentTypes['createEmbeddedRequestUrlDocument'][0])
    {
        return $this->createEmbeddedRequestUrlDocumentAsyncWithHttpInfo($embedded_document_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createEmbeddedRequestUrlDocumentAsyncWithHttpInfo
     *
     * Generates a send URL which embeds document sending process into your application.
     *
     * @param  \BoldSign\Model\EmbeddedDocumentRequest $embedded_document_request The embedded send document request body. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createEmbeddedRequestUrlDocument'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createEmbeddedRequestUrlDocumentAsyncWithHttpInfo($embedded_document_request = null, string $contentType = self::contentTypes['createEmbeddedRequestUrlDocument'][0])
    {
        $returnType = '\BoldSign\Model\EmbeddedSendCreated';
        $request = $this->createEmbeddedRequestUrlDocumentRequest($embedded_document_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createEmbeddedRequestUrlDocument'
     *
     * @param  \BoldSign\Model\EmbeddedDocumentRequest $embedded_document_request The embedded send document request body. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createEmbeddedRequestUrlDocument'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createEmbeddedRequestUrlDocumentRequest($embedded_document_request = null, string $contentType = self::contentTypes['createEmbeddedRequestUrlDocument'][0])
    {



        $resourcePath = '/v1/document/createEmbeddedRequestUrl';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        if(!is_array($embedded_document_request)) {
            $formParams = ObjectSerializer::getFormParams(
                $embedded_document_request
            );
        }
        else {
            foreach($embedded_document_request as $param){
                $formParams = ObjectSerializer::getFormParams(
                $param);
            }
        }

        $multipart = !empty($formParams);




        $headers = $this->headerSelector->selectHeaders(
            $multipart ? ['multipart/form-data'] : ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) === 0) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($embedded_document_request));
            } else {
                $httpBody = $embedded_document_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                if (!empty($body)) {
                    $multipartContents[] = [
                        'name'     => 'body',
                        'contents' => $body,
                        'headers'  => ['Content-Type' => 'application/json'],
                    ];
                }

                if ($payloadHook = $this->config->getPayloadHook()) {
                    $payloadHook('multipart', $multipartContents, $embedded_document_request);
                }
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-KEY');
        if ($apiKey !== null) {
            $headers['X-API-KEY'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteDocument
     *
     * Delete the document.
     *
     * @param  string $document_id Document Id. (required)
     * @param  bool $delete_permanently Delete Permanently. (optional, default to false)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteDocument'] to see the possible values for this operation
     *
     * @throws \BoldSign\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteDocument($document_id, $delete_permanently = false, string $contentType = self::contentTypes['deleteDocument'][0])
    {
        $this->deleteDocumentWithHttpInfo($document_id, $delete_permanently, $contentType);
    }

    /**
     * Operation deleteDocumentWithHttpInfo
     *
     * Delete the document.
     *
     * @param  string $document_id Document Id. (required)
     * @param  bool $delete_permanently Delete Permanently. (optional, default to false)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteDocument'] to see the possible values for this operation
     *
     * @throws \BoldSign\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteDocumentWithHttpInfo($document_id, $delete_permanently = false, string $contentType = self::contentTypes['deleteDocument'][0])
    {
        $request = $this->deleteDocumentRequest($document_id, $delete_permanently, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BoldSign\Model\ErrorResult',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BoldSign\Model\ErrorResult',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deleteDocumentAsync
     *
     * Delete the document.
     *
     * @param  string $document_id Document Id. (required)
     * @param  bool $delete_permanently Delete Permanently. (optional, default to false)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteDocument'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteDocumentAsync($document_id, $delete_permanently = false, string $contentType = self::contentTypes['deleteDocument'][0])
    {
        return $this->deleteDocumentAsyncWithHttpInfo($document_id, $delete_permanently, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteDocumentAsyncWithHttpInfo
     *
     * Delete the document.
     *
     * @param  string $document_id Document Id. (required)
     * @param  bool $delete_permanently Delete Permanently. (optional, default to false)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteDocument'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteDocumentAsyncWithHttpInfo($document_id, $delete_permanently = false, string $contentType = self::contentTypes['deleteDocument'][0])
    {
        $returnType = '';
        $request = $this->deleteDocumentRequest($document_id, $delete_permanently, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteDocument'
     *
     * @param  string $document_id Document Id. (required)
     * @param  bool $delete_permanently Delete Permanently. (optional, default to false)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteDocument'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function deleteDocumentRequest($document_id, $delete_permanently = false, string $contentType = self::contentTypes['deleteDocument'][0])
    {

        // verify the required parameter 'document_id' is set
        if ($document_id === null || (is_array($document_id) && count($document_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $document_id when calling deleteDocument'
            );
        }



        $resourcePath = '/v1/document/delete';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $document_id,
            'documentId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $delete_permanently,
            'deletePermanently', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            $multipart ? ['multipart/form-data'] : ['application/json;odata.metadata=minimal;odata.streaming=true', 'application/json;odata.metadata=minimal;odata.streaming=false', 'application/json;odata.metadata=minimal', 'application/json;odata.metadata=full;odata.streaming=true', 'application/json;odata.metadata=full;odata.streaming=false', 'application/json;odata.metadata=full', 'application/json;odata.metadata=none;odata.streaming=true', 'application/json;odata.metadata=none;odata.streaming=false', 'application/json;odata.metadata=none', 'application/json;odata.streaming=true', 'application/json;odata.streaming=false', 'application/json', 'application/xml', 'application/prs.odatatestxx-odata', 'text/plain', 'text/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                if (!empty($body)) {
                    $multipartContents[] = [
                        'name'     => 'body',
                        'contents' => $body,
                        'headers'  => ['Content-Type' => 'application/json'],
                    ];
                }

                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-KEY');
        if ($apiKey !== null) {
            $headers['X-API-KEY'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteTag
     *
     * Delete the Tags in Documents.
     *
     * @param  \BoldSign\Model\DocumentTags $document_tags Contains DocumentId and LabelNames for Adding Tags. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteTag'] to see the possible values for this operation
     *
     * @throws \BoldSign\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteTag($document_tags = null, string $contentType = self::contentTypes['deleteTag'][0])
    {
        $this->deleteTagWithHttpInfo($document_tags, $contentType);
    }

    /**
     * Operation deleteTagWithHttpInfo
     *
     * Delete the Tags in Documents.
     *
     * @param  \BoldSign\Model\DocumentTags $document_tags Contains DocumentId and LabelNames for Adding Tags. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteTag'] to see the possible values for this operation
     *
     * @throws \BoldSign\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteTagWithHttpInfo($document_tags = null, string $contentType = self::contentTypes['deleteTag'][0])
    {
        $request = $this->deleteTagRequest($document_tags, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BoldSign\Model\ErrorResult',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BoldSign\Model\ErrorResult',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deleteTagAsync
     *
     * Delete the Tags in Documents.
     *
     * @param  \BoldSign\Model\DocumentTags $document_tags Contains DocumentId and LabelNames for Adding Tags. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteTag'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteTagAsync($document_tags = null, string $contentType = self::contentTypes['deleteTag'][0])
    {
        return $this->deleteTagAsyncWithHttpInfo($document_tags, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteTagAsyncWithHttpInfo
     *
     * Delete the Tags in Documents.
     *
     * @param  \BoldSign\Model\DocumentTags $document_tags Contains DocumentId and LabelNames for Adding Tags. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteTag'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteTagAsyncWithHttpInfo($document_tags = null, string $contentType = self::contentTypes['deleteTag'][0])
    {
        $returnType = '';
        $request = $this->deleteTagRequest($document_tags, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteTag'
     *
     * @param  \BoldSign\Model\DocumentTags $document_tags Contains DocumentId and LabelNames for Adding Tags. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteTag'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function deleteTagRequest($document_tags = null, string $contentType = self::contentTypes['deleteTag'][0])
    {



        $resourcePath = '/v1/document/deleteTags';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        if(!is_array($document_tags)) {
            $formParams = ObjectSerializer::getFormParams(
                $document_tags
            );
        }
        else {
            foreach($document_tags as $param){
                $formParams = ObjectSerializer::getFormParams(
                $param);
            }
        }

        $multipart = !empty($formParams);




        $headers = $this->headerSelector->selectHeaders(
            $multipart ? ['multipart/form-data'] : ['application/json;odata.metadata=minimal;odata.streaming=true', 'application/json;odata.metadata=minimal;odata.streaming=false', 'application/json;odata.metadata=minimal', 'application/json;odata.metadata=full;odata.streaming=true', 'application/json;odata.metadata=full;odata.streaming=false', 'application/json;odata.metadata=full', 'application/json;odata.metadata=none;odata.streaming=true', 'application/json;odata.metadata=none;odata.streaming=false', 'application/json;odata.metadata=none', 'application/json;odata.streaming=true', 'application/json;odata.streaming=false', 'application/json', 'application/xml', 'application/prs.odatatestxx-odata', 'text/plain', 'text/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) === 0) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($document_tags));
            } else {
                $httpBody = $document_tags;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                if (!empty($body)) {
                    $multipartContents[] = [
                        'name'     => 'body',
                        'contents' => $body,
                        'headers'  => ['Content-Type' => 'application/json'],
                    ];
                }

                if ($payloadHook = $this->config->getPayloadHook()) {
                    $payloadHook('multipart', $multipartContents, $document_tags);
                }
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-KEY');
        if ($apiKey !== null) {
            $headers['X-API-KEY'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation downloadAttachment
     *
     * Download the Attachment.
     *
     * @param  string $document_id Document Id. (required)
     * @param  string $attachment_id Attachment Id(Get attachment ID from Properties API). (required)
     * @param  string $on_behalf_of The on behalfof email address. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['downloadAttachment'] to see the possible values for this operation
     *
     * @throws \BoldSign\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \SplFileObject|\BoldSign\Model\ErrorResult|\BoldSign\Model\ErrorResult
     */
    public function downloadAttachment($document_id, $attachment_id, $on_behalf_of = null, string $contentType = self::contentTypes['downloadAttachment'][0])
    {
        list($response) = $this->downloadAttachmentWithHttpInfo($document_id, $attachment_id, $on_behalf_of, $contentType);
        return $response;
    }

    /**
     * Operation downloadAttachmentWithHttpInfo
     *
     * Download the Attachment.
     *
     * @param  string $document_id Document Id. (required)
     * @param  string $attachment_id Attachment Id(Get attachment ID from Properties API). (required)
     * @param  string $on_behalf_of The on behalfof email address. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['downloadAttachment'] to see the possible values for this operation
     *
     * @throws \BoldSign\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject|\BoldSign\Model\ErrorResult|\BoldSign\Model\ErrorResult, HTTP status code, HTTP response headers (array of strings)
     */
    public function downloadAttachmentWithHttpInfo($document_id, $attachment_id, $on_behalf_of = null, string $contentType = self::contentTypes['downloadAttachment'][0])
    {
        $request = $this->downloadAttachmentRequest($document_id, $attachment_id, $on_behalf_of, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\SplFileObject' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\SplFileObject' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\SplFileObject', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 401:
                    if ('\BoldSign\Model\ErrorResult' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\BoldSign\Model\ErrorResult' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\BoldSign\Model\ErrorResult', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 403:
                    if ('\BoldSign\Model\ErrorResult' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\BoldSign\Model\ErrorResult' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\BoldSign\Model\ErrorResult', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\SplFileObject';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BoldSign\Model\ErrorResult',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BoldSign\Model\ErrorResult',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation downloadAttachmentAsync
     *
     * Download the Attachment.
     *
     * @param  string $document_id Document Id. (required)
     * @param  string $attachment_id Attachment Id(Get attachment ID from Properties API). (required)
     * @param  string $on_behalf_of The on behalfof email address. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['downloadAttachment'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function downloadAttachmentAsync($document_id, $attachment_id, $on_behalf_of = null, string $contentType = self::contentTypes['downloadAttachment'][0])
    {
        return $this->downloadAttachmentAsyncWithHttpInfo($document_id, $attachment_id, $on_behalf_of, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation downloadAttachmentAsyncWithHttpInfo
     *
     * Download the Attachment.
     *
     * @param  string $document_id Document Id. (required)
     * @param  string $attachment_id Attachment Id(Get attachment ID from Properties API). (required)
     * @param  string $on_behalf_of The on behalfof email address. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['downloadAttachment'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function downloadAttachmentAsyncWithHttpInfo($document_id, $attachment_id, $on_behalf_of = null, string $contentType = self::contentTypes['downloadAttachment'][0])
    {
        $returnType = '\SplFileObject';
        $request = $this->downloadAttachmentRequest($document_id, $attachment_id, $on_behalf_of, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'downloadAttachment'
     *
     * @param  string $document_id Document Id. (required)
     * @param  string $attachment_id Attachment Id(Get attachment ID from Properties API). (required)
     * @param  string $on_behalf_of The on behalfof email address. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['downloadAttachment'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function downloadAttachmentRequest($document_id, $attachment_id, $on_behalf_of = null, string $contentType = self::contentTypes['downloadAttachment'][0])
    {

        // verify the required parameter 'document_id' is set
        if ($document_id === null || (is_array($document_id) && count($document_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $document_id when calling downloadAttachment'
            );
        }

        // verify the required parameter 'attachment_id' is set
        if ($attachment_id === null || (is_array($attachment_id) && count($attachment_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $attachment_id when calling downloadAttachment'
            );
        }



        $resourcePath = '/v1/document/downloadAttachment';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $document_id,
            'documentId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $attachment_id,
            'attachmentId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $on_behalf_of,
            'onBehalfOf', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            $multipart ? ['multipart/form-data'] : ['application/json;odata.metadata=minimal;odata.streaming=true', 'application/json;odata.metadata=minimal;odata.streaming=false', 'application/json;odata.metadata=minimal', 'application/json;odata.metadata=full;odata.streaming=true', 'application/json;odata.metadata=full;odata.streaming=false', 'application/json;odata.metadata=full', 'application/json;odata.metadata=none;odata.streaming=true', 'application/json;odata.metadata=none;odata.streaming=false', 'application/json;odata.metadata=none', 'application/json;odata.streaming=true', 'application/json;odata.streaming=false', 'application/json', 'application/xml', 'application/prs.odatatestxx-odata', 'text/plain', 'text/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                if (!empty($body)) {
                    $multipartContents[] = [
                        'name'     => 'body',
                        'contents' => $body,
                        'headers'  => ['Content-Type' => 'application/json'],
                    ];
                }

                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-KEY');
        if ($apiKey !== null) {
            $headers['X-API-KEY'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation downloadAuditLog
     *
     * Download the audit trail document.
     *
     * @param  string $document_id Document Id. (required)
     * @param  string $on_behalf_of The on behalfof email address. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['downloadAuditLog'] to see the possible values for this operation
     *
     * @throws \BoldSign\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \SplFileObject|\BoldSign\Model\ErrorResult|\BoldSign\Model\ErrorResult
     */
    public function downloadAuditLog($document_id, $on_behalf_of = null, string $contentType = self::contentTypes['downloadAuditLog'][0])
    {
        list($response) = $this->downloadAuditLogWithHttpInfo($document_id, $on_behalf_of, $contentType);
        return $response;
    }

    /**
     * Operation downloadAuditLogWithHttpInfo
     *
     * Download the audit trail document.
     *
     * @param  string $document_id Document Id. (required)
     * @param  string $on_behalf_of The on behalfof email address. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['downloadAuditLog'] to see the possible values for this operation
     *
     * @throws \BoldSign\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject|\BoldSign\Model\ErrorResult|\BoldSign\Model\ErrorResult, HTTP status code, HTTP response headers (array of strings)
     */
    public function downloadAuditLogWithHttpInfo($document_id, $on_behalf_of = null, string $contentType = self::contentTypes['downloadAuditLog'][0])
    {
        $request = $this->downloadAuditLogRequest($document_id, $on_behalf_of, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\SplFileObject' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\SplFileObject' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\SplFileObject', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 401:
                    if ('\BoldSign\Model\ErrorResult' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\BoldSign\Model\ErrorResult' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\BoldSign\Model\ErrorResult', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 403:
                    if ('\BoldSign\Model\ErrorResult' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\BoldSign\Model\ErrorResult' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\BoldSign\Model\ErrorResult', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\SplFileObject';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BoldSign\Model\ErrorResult',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BoldSign\Model\ErrorResult',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation downloadAuditLogAsync
     *
     * Download the audit trail document.
     *
     * @param  string $document_id Document Id. (required)
     * @param  string $on_behalf_of The on behalfof email address. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['downloadAuditLog'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function downloadAuditLogAsync($document_id, $on_behalf_of = null, string $contentType = self::contentTypes['downloadAuditLog'][0])
    {
        return $this->downloadAuditLogAsyncWithHttpInfo($document_id, $on_behalf_of, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation downloadAuditLogAsyncWithHttpInfo
     *
     * Download the audit trail document.
     *
     * @param  string $document_id Document Id. (required)
     * @param  string $on_behalf_of The on behalfof email address. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['downloadAuditLog'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function downloadAuditLogAsyncWithHttpInfo($document_id, $on_behalf_of = null, string $contentType = self::contentTypes['downloadAuditLog'][0])
    {
        $returnType = '\SplFileObject';
        $request = $this->downloadAuditLogRequest($document_id, $on_behalf_of, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'downloadAuditLog'
     *
     * @param  string $document_id Document Id. (required)
     * @param  string $on_behalf_of The on behalfof email address. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['downloadAuditLog'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function downloadAuditLogRequest($document_id, $on_behalf_of = null, string $contentType = self::contentTypes['downloadAuditLog'][0])
    {

        // verify the required parameter 'document_id' is set
        if ($document_id === null || (is_array($document_id) && count($document_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $document_id when calling downloadAuditLog'
            );
        }



        $resourcePath = '/v1/document/downloadAuditLog';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $document_id,
            'documentId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $on_behalf_of,
            'onBehalfOf', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            $multipart ? ['multipart/form-data'] : ['application/json;odata.metadata=minimal;odata.streaming=true', 'application/json;odata.metadata=minimal;odata.streaming=false', 'application/json;odata.metadata=minimal', 'application/json;odata.metadata=full;odata.streaming=true', 'application/json;odata.metadata=full;odata.streaming=false', 'application/json;odata.metadata=full', 'application/json;odata.metadata=none;odata.streaming=true', 'application/json;odata.metadata=none;odata.streaming=false', 'application/json;odata.metadata=none', 'application/json;odata.streaming=true', 'application/json;odata.streaming=false', 'application/json', 'application/xml', 'application/prs.odatatestxx-odata', 'text/plain', 'text/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                if (!empty($body)) {
                    $multipartContents[] = [
                        'name'     => 'body',
                        'contents' => $body,
                        'headers'  => ['Content-Type' => 'application/json'],
                    ];
                }

                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-KEY');
        if ($apiKey !== null) {
            $headers['X-API-KEY'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation downloadDocument
     *
     * Download the document.
     *
     * @param  string $document_id Document Id. (required)
     * @param  string $on_behalf_of The on behalfof email address. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['downloadDocument'] to see the possible values for this operation
     *
     * @throws \BoldSign\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \SplFileObject|\BoldSign\Model\ErrorResult|\BoldSign\Model\ErrorResult
     */
    public function downloadDocument($document_id, $on_behalf_of = null, string $contentType = self::contentTypes['downloadDocument'][0])
    {
        list($response) = $this->downloadDocumentWithHttpInfo($document_id, $on_behalf_of, $contentType);
        return $response;
    }

    /**
     * Operation downloadDocumentWithHttpInfo
     *
     * Download the document.
     *
     * @param  string $document_id Document Id. (required)
     * @param  string $on_behalf_of The on behalfof email address. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['downloadDocument'] to see the possible values for this operation
     *
     * @throws \BoldSign\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject|\BoldSign\Model\ErrorResult|\BoldSign\Model\ErrorResult, HTTP status code, HTTP response headers (array of strings)
     */
    public function downloadDocumentWithHttpInfo($document_id, $on_behalf_of = null, string $contentType = self::contentTypes['downloadDocument'][0])
    {
        $request = $this->downloadDocumentRequest($document_id, $on_behalf_of, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\SplFileObject' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\SplFileObject' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\SplFileObject', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 401:
                    if ('\BoldSign\Model\ErrorResult' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\BoldSign\Model\ErrorResult' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\BoldSign\Model\ErrorResult', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 403:
                    if ('\BoldSign\Model\ErrorResult' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\BoldSign\Model\ErrorResult' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\BoldSign\Model\ErrorResult', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\SplFileObject';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BoldSign\Model\ErrorResult',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BoldSign\Model\ErrorResult',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation downloadDocumentAsync
     *
     * Download the document.
     *
     * @param  string $document_id Document Id. (required)
     * @param  string $on_behalf_of The on behalfof email address. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['downloadDocument'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function downloadDocumentAsync($document_id, $on_behalf_of = null, string $contentType = self::contentTypes['downloadDocument'][0])
    {
        return $this->downloadDocumentAsyncWithHttpInfo($document_id, $on_behalf_of, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation downloadDocumentAsyncWithHttpInfo
     *
     * Download the document.
     *
     * @param  string $document_id Document Id. (required)
     * @param  string $on_behalf_of The on behalfof email address. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['downloadDocument'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function downloadDocumentAsyncWithHttpInfo($document_id, $on_behalf_of = null, string $contentType = self::contentTypes['downloadDocument'][0])
    {
        $returnType = '\SplFileObject';
        $request = $this->downloadDocumentRequest($document_id, $on_behalf_of, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'downloadDocument'
     *
     * @param  string $document_id Document Id. (required)
     * @param  string $on_behalf_of The on behalfof email address. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['downloadDocument'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function downloadDocumentRequest($document_id, $on_behalf_of = null, string $contentType = self::contentTypes['downloadDocument'][0])
    {

        // verify the required parameter 'document_id' is set
        if ($document_id === null || (is_array($document_id) && count($document_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $document_id when calling downloadDocument'
            );
        }



        $resourcePath = '/v1/document/download';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $document_id,
            'documentId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $on_behalf_of,
            'onBehalfOf', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            $multipart ? ['multipart/form-data'] : ['application/json;odata.metadata=minimal;odata.streaming=true', 'application/json;odata.metadata=minimal;odata.streaming=false', 'application/json;odata.metadata=minimal', 'application/json;odata.metadata=full;odata.streaming=true', 'application/json;odata.metadata=full;odata.streaming=false', 'application/json;odata.metadata=full', 'application/json;odata.metadata=none;odata.streaming=true', 'application/json;odata.metadata=none;odata.streaming=false', 'application/json;odata.metadata=none', 'application/json;odata.streaming=true', 'application/json;odata.streaming=false', 'application/json', 'application/xml', 'application/prs.odatatestxx-odata', 'text/plain', 'text/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                if (!empty($body)) {
                    $multipartContents[] = [
                        'name'     => 'body',
                        'contents' => $body,
                        'headers'  => ['Content-Type' => 'application/json'],
                    ];
                }

                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-KEY');
        if ($apiKey !== null) {
            $headers['X-API-KEY'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation extendExpiry
     *
     * Extends the expiration date of the document.
     *
     * @param  string $document_id Document Id. (required)
     * @param  \BoldSign\Model\ExtendExpiry $extend_expiry The new expiry value should be specified in yyyy-MM-dd format for days type, ISO date time format for specific date time and integer for hours type. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extendExpiry'] to see the possible values for this operation
     *
     * @throws \BoldSign\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function extendExpiry($document_id, $extend_expiry = null, string $contentType = self::contentTypes['extendExpiry'][0])
    {
        $this->extendExpiryWithHttpInfo($document_id, $extend_expiry, $contentType);
    }

    /**
     * Operation extendExpiryWithHttpInfo
     *
     * Extends the expiration date of the document.
     *
     * @param  string $document_id Document Id. (required)
     * @param  \BoldSign\Model\ExtendExpiry $extend_expiry The new expiry value should be specified in yyyy-MM-dd format for days type, ISO date time format for specific date time and integer for hours type. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extendExpiry'] to see the possible values for this operation
     *
     * @throws \BoldSign\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function extendExpiryWithHttpInfo($document_id, $extend_expiry = null, string $contentType = self::contentTypes['extendExpiry'][0])
    {
        $request = $this->extendExpiryRequest($document_id, $extend_expiry, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BoldSign\Model\ErrorResult',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BoldSign\Model\ErrorResult',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation extendExpiryAsync
     *
     * Extends the expiration date of the document.
     *
     * @param  string $document_id Document Id. (required)
     * @param  \BoldSign\Model\ExtendExpiry $extend_expiry The new expiry value should be specified in yyyy-MM-dd format for days type, ISO date time format for specific date time and integer for hours type. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extendExpiry'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extendExpiryAsync($document_id, $extend_expiry = null, string $contentType = self::contentTypes['extendExpiry'][0])
    {
        return $this->extendExpiryAsyncWithHttpInfo($document_id, $extend_expiry, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation extendExpiryAsyncWithHttpInfo
     *
     * Extends the expiration date of the document.
     *
     * @param  string $document_id Document Id. (required)
     * @param  \BoldSign\Model\ExtendExpiry $extend_expiry The new expiry value should be specified in yyyy-MM-dd format for days type, ISO date time format for specific date time and integer for hours type. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extendExpiry'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extendExpiryAsyncWithHttpInfo($document_id, $extend_expiry = null, string $contentType = self::contentTypes['extendExpiry'][0])
    {
        $returnType = '';
        $request = $this->extendExpiryRequest($document_id, $extend_expiry, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'extendExpiry'
     *
     * @param  string $document_id Document Id. (required)
     * @param  \BoldSign\Model\ExtendExpiry $extend_expiry The new expiry value should be specified in yyyy-MM-dd format for days type, ISO date time format for specific date time and integer for hours type. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extendExpiry'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function extendExpiryRequest($document_id, $extend_expiry = null, string $contentType = self::contentTypes['extendExpiry'][0])
    {

        // verify the required parameter 'document_id' is set
        if ($document_id === null || (is_array($document_id) && count($document_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $document_id when calling extendExpiry'
            );
        }



        $resourcePath = '/v1/document/extendExpiry';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        if(!is_array($extend_expiry)) {
            $formParams = ObjectSerializer::getFormParams(
                $extend_expiry
            );
        }
        else {
            foreach($extend_expiry as $param){
                $formParams = ObjectSerializer::getFormParams(
                $param);
            }
        }

        $multipart = !empty($formParams);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $document_id,
            'documentId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            $multipart ? ['multipart/form-data'] : ['application/json;odata.metadata=minimal;odata.streaming=true', 'application/json;odata.metadata=minimal;odata.streaming=false', 'application/json;odata.metadata=minimal', 'application/json;odata.metadata=full;odata.streaming=true', 'application/json;odata.metadata=full;odata.streaming=false', 'application/json;odata.metadata=full', 'application/json;odata.metadata=none;odata.streaming=true', 'application/json;odata.metadata=none;odata.streaming=false', 'application/json;odata.metadata=none', 'application/json;odata.streaming=true', 'application/json;odata.streaming=false', 'application/json', 'application/xml', 'application/prs.odatatestxx-odata', 'text/plain', 'text/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) === 0) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($extend_expiry));
            } else {
                $httpBody = $extend_expiry;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                if (!empty($body)) {
                    $multipartContents[] = [
                        'name'     => 'body',
                        'contents' => $body,
                        'headers'  => ['Content-Type' => 'application/json'],
                    ];
                }

                if ($payloadHook = $this->config->getPayloadHook()) {
                    $payloadHook('multipart', $multipartContents, $extend_expiry);
                }
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-KEY');
        if ($apiKey !== null) {
            $headers['X-API-KEY'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PATCH',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getEmbeddedSignLink
     *
     * Get sign link for Embedded Sign.
     *
     * @param  string $document_id document_id (required)
     * @param  string $signer_email signer_email (optional)
     * @param  string $country_code country_code (optional)
     * @param  string $phone_number phone_number (optional)
     * @param  \DateTime $sign_link_valid_till sign_link_valid_till (optional)
     * @param  string $redirect_url redirect_url (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getEmbeddedSignLink'] to see the possible values for this operation
     *
     * @throws \BoldSign\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \BoldSign\Model\EmbeddedSigningLink|\BoldSign\Model\ErrorResult|\BoldSign\Model\ErrorResult
     */
    public function getEmbeddedSignLink($document_id, $signer_email = null, $country_code = null, $phone_number = null, $sign_link_valid_till = null, $redirect_url = null, string $contentType = self::contentTypes['getEmbeddedSignLink'][0])
    {
        list($response) = $this->getEmbeddedSignLinkWithHttpInfo($document_id, $signer_email, $country_code, $phone_number, $sign_link_valid_till, $redirect_url, $contentType);
        return $response;
    }

    /**
     * Operation getEmbeddedSignLinkWithHttpInfo
     *
     * Get sign link for Embedded Sign.
     *
     * @param  string $document_id (required)
     * @param  string $signer_email (optional)
     * @param  string $country_code (optional)
     * @param  string $phone_number (optional)
     * @param  \DateTime $sign_link_valid_till (optional)
     * @param  string $redirect_url (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getEmbeddedSignLink'] to see the possible values for this operation
     *
     * @throws \BoldSign\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \BoldSign\Model\EmbeddedSigningLink|\BoldSign\Model\ErrorResult|\BoldSign\Model\ErrorResult, HTTP status code, HTTP response headers (array of strings)
     */
    public function getEmbeddedSignLinkWithHttpInfo($document_id, $signer_email = null, $country_code = null, $phone_number = null, $sign_link_valid_till = null, $redirect_url = null, string $contentType = self::contentTypes['getEmbeddedSignLink'][0])
    {
        $request = $this->getEmbeddedSignLinkRequest($document_id, $signer_email, $country_code, $phone_number, $sign_link_valid_till, $redirect_url, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\BoldSign\Model\EmbeddedSigningLink' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\BoldSign\Model\EmbeddedSigningLink' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\BoldSign\Model\EmbeddedSigningLink', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 401:
                    if ('\BoldSign\Model\ErrorResult' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\BoldSign\Model\ErrorResult' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\BoldSign\Model\ErrorResult', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 403:
                    if ('\BoldSign\Model\ErrorResult' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\BoldSign\Model\ErrorResult' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\BoldSign\Model\ErrorResult', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\BoldSign\Model\EmbeddedSigningLink';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BoldSign\Model\EmbeddedSigningLink',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BoldSign\Model\ErrorResult',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BoldSign\Model\ErrorResult',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getEmbeddedSignLinkAsync
     *
     * Get sign link for Embedded Sign.
     *
     * @param  string $document_id (required)
     * @param  string $signer_email (optional)
     * @param  string $country_code (optional)
     * @param  string $phone_number (optional)
     * @param  \DateTime $sign_link_valid_till (optional)
     * @param  string $redirect_url (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getEmbeddedSignLink'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getEmbeddedSignLinkAsync($document_id, $signer_email = null, $country_code = null, $phone_number = null, $sign_link_valid_till = null, $redirect_url = null, string $contentType = self::contentTypes['getEmbeddedSignLink'][0])
    {
        return $this->getEmbeddedSignLinkAsyncWithHttpInfo($document_id, $signer_email, $country_code, $phone_number, $sign_link_valid_till, $redirect_url, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getEmbeddedSignLinkAsyncWithHttpInfo
     *
     * Get sign link for Embedded Sign.
     *
     * @param  string $document_id (required)
     * @param  string $signer_email (optional)
     * @param  string $country_code (optional)
     * @param  string $phone_number (optional)
     * @param  \DateTime $sign_link_valid_till (optional)
     * @param  string $redirect_url (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getEmbeddedSignLink'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getEmbeddedSignLinkAsyncWithHttpInfo($document_id, $signer_email = null, $country_code = null, $phone_number = null, $sign_link_valid_till = null, $redirect_url = null, string $contentType = self::contentTypes['getEmbeddedSignLink'][0])
    {
        $returnType = '\BoldSign\Model\EmbeddedSigningLink';
        $request = $this->getEmbeddedSignLinkRequest($document_id, $signer_email, $country_code, $phone_number, $sign_link_valid_till, $redirect_url, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getEmbeddedSignLink'
     *
     * @param  string $document_id (required)
     * @param  string $signer_email (optional)
     * @param  string $country_code (optional)
     * @param  string $phone_number (optional)
     * @param  \DateTime $sign_link_valid_till (optional)
     * @param  string $redirect_url (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getEmbeddedSignLink'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getEmbeddedSignLinkRequest($document_id, $signer_email = null, $country_code = null, $phone_number = null, $sign_link_valid_till = null, $redirect_url = null, string $contentType = self::contentTypes['getEmbeddedSignLink'][0])
    {

        // verify the required parameter 'document_id' is set
        if ($document_id === null || (is_array($document_id) && count($document_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $document_id when calling getEmbeddedSignLink'
            );
        }







        $resourcePath = '/v1/document/getEmbeddedSignLink';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $document_id,
            'DocumentId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $signer_email,
            'SignerEmail', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $country_code,
            'CountryCode', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $phone_number,
            'PhoneNumber', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sign_link_valid_till,
            'SignLinkValidTill', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $redirect_url,
            'RedirectUrl', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            $multipart ? ['multipart/form-data'] : ['application/json;odata.metadata=minimal;odata.streaming=true', 'application/json;odata.metadata=minimal;odata.streaming=false', 'application/json;odata.metadata=minimal', 'application/json;odata.metadata=full;odata.streaming=true', 'application/json;odata.metadata=full;odata.streaming=false', 'application/json;odata.metadata=full', 'application/json;odata.metadata=none;odata.streaming=true', 'application/json;odata.metadata=none;odata.streaming=false', 'application/json;odata.metadata=none', 'application/json;odata.streaming=true', 'application/json;odata.streaming=false', 'application/json', 'application/xml', 'application/prs.odatatestxx-odata', 'text/plain', 'text/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                if (!empty($body)) {
                    $multipartContents[] = [
                        'name'     => 'body',
                        'contents' => $body,
                        'headers'  => ['Content-Type' => 'application/json'],
                    ];
                }

                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-KEY');
        if ($apiKey !== null) {
            $headers['X-API-KEY'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getProperties
     *
     * Get summary of the document.
     *
     * @param  string $document_id Document Id. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getProperties'] to see the possible values for this operation
     *
     * @throws \BoldSign\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \BoldSign\Model\DocumentProperties|\BoldSign\Model\ErrorResult|\BoldSign\Model\ErrorResult
     */
    public function getProperties($document_id, string $contentType = self::contentTypes['getProperties'][0])
    {
        list($response) = $this->getPropertiesWithHttpInfo($document_id, $contentType);
        return $response;
    }

    /**
     * Operation getPropertiesWithHttpInfo
     *
     * Get summary of the document.
     *
     * @param  string $document_id Document Id. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getProperties'] to see the possible values for this operation
     *
     * @throws \BoldSign\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \BoldSign\Model\DocumentProperties|\BoldSign\Model\ErrorResult|\BoldSign\Model\ErrorResult, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPropertiesWithHttpInfo($document_id, string $contentType = self::contentTypes['getProperties'][0])
    {
        $request = $this->getPropertiesRequest($document_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\BoldSign\Model\DocumentProperties' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\BoldSign\Model\DocumentProperties' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\BoldSign\Model\DocumentProperties', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 401:
                    if ('\BoldSign\Model\ErrorResult' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\BoldSign\Model\ErrorResult' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\BoldSign\Model\ErrorResult', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 403:
                    if ('\BoldSign\Model\ErrorResult' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\BoldSign\Model\ErrorResult' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\BoldSign\Model\ErrorResult', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\BoldSign\Model\DocumentProperties';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BoldSign\Model\DocumentProperties',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BoldSign\Model\ErrorResult',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BoldSign\Model\ErrorResult',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getPropertiesAsync
     *
     * Get summary of the document.
     *
     * @param  string $document_id Document Id. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getProperties'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPropertiesAsync($document_id, string $contentType = self::contentTypes['getProperties'][0])
    {
        return $this->getPropertiesAsyncWithHttpInfo($document_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getPropertiesAsyncWithHttpInfo
     *
     * Get summary of the document.
     *
     * @param  string $document_id Document Id. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getProperties'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPropertiesAsyncWithHttpInfo($document_id, string $contentType = self::contentTypes['getProperties'][0])
    {
        $returnType = '\BoldSign\Model\DocumentProperties';
        $request = $this->getPropertiesRequest($document_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getProperties'
     *
     * @param  string $document_id Document Id. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getProperties'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getPropertiesRequest($document_id, string $contentType = self::contentTypes['getProperties'][0])
    {

        // verify the required parameter 'document_id' is set
        if ($document_id === null || (is_array($document_id) && count($document_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $document_id when calling getProperties'
            );
        }


        $resourcePath = '/v1/document/properties';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $document_id,
            'documentId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            $multipart ? ['multipart/form-data'] : ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                if (!empty($body)) {
                    $multipartContents[] = [
                        'name'     => 'body',
                        'contents' => $body,
                        'headers'  => ['Content-Type' => 'application/json'],
                    ];
                }

                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-KEY');
        if ($apiKey !== null) {
            $headers['X-API-KEY'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listDocuments
     *
     * List user documents.
     *
     * @param  int $page Page index specified in get document list request. (required)
     * @param  string[] $sent_by sent_by (optional)
     * @param  string[] $recipients recipients (optional)
     * @param  string $transmit_type transmit_type (optional)
     * @param  int $page_size Page size specified in get document list request. (optional, default to 10)
     * @param  \DateTime $start_date Start date of the document (optional)
     * @param  string[] $status Status of the document such as In-progress, Completed, Decline, Expired, Revoked, Draft. (optional)
     * @param  \DateTime $end_date End date of the document (optional)
     * @param  string $search_key Documents can be listed by the search key present in the document like document title, document ID, sender or recipient(s) name, etc., (optional)
     * @param  string[] $labels Labels of the document. (optional)
     * @param  int $next_cursor Next cursor value for pagination, required for fetching the next set of documents beyond 10,000 records. (optional)
     * @param  string[] $brand_ids BrandId(s) of the document. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listDocuments'] to see the possible values for this operation
     *
     * @throws \BoldSign\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \BoldSign\Model\DocumentRecords|\BoldSign\Model\ErrorResult
     */
    public function listDocuments($page, $sent_by = null, $recipients = null, $transmit_type = null, $page_size = 10, $start_date = null, $status = null, $end_date = null, $search_key = null, $labels = null, $next_cursor = null, $brand_ids = null, string $contentType = self::contentTypes['listDocuments'][0])
    {
        list($response) = $this->listDocumentsWithHttpInfo($page, $sent_by, $recipients, $transmit_type, $page_size, $start_date, $status, $end_date, $search_key, $labels, $next_cursor, $brand_ids, $contentType);
        return $response;
    }

    /**
     * Operation listDocumentsWithHttpInfo
     *
     * List user documents.
     *
     * @param  int $page Page index specified in get document list request. (required)
     * @param  string[] $sent_by (optional)
     * @param  string[] $recipients (optional)
     * @param  string $transmit_type (optional)
     * @param  int $page_size Page size specified in get document list request. (optional, default to 10)
     * @param  \DateTime $start_date Start date of the document (optional)
     * @param  string[] $status Status of the document such as In-progress, Completed, Decline, Expired, Revoked, Draft. (optional)
     * @param  \DateTime $end_date End date of the document (optional)
     * @param  string $search_key Documents can be listed by the search key present in the document like document title, document ID, sender or recipient(s) name, etc., (optional)
     * @param  string[] $labels Labels of the document. (optional)
     * @param  int $next_cursor Next cursor value for pagination, required for fetching the next set of documents beyond 10,000 records. (optional)
     * @param  string[] $brand_ids BrandId(s) of the document. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listDocuments'] to see the possible values for this operation
     *
     * @throws \BoldSign\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \BoldSign\Model\DocumentRecords|\BoldSign\Model\ErrorResult, HTTP status code, HTTP response headers (array of strings)
     */
    public function listDocumentsWithHttpInfo($page, $sent_by = null, $recipients = null, $transmit_type = null, $page_size = 10, $start_date = null, $status = null, $end_date = null, $search_key = null, $labels = null, $next_cursor = null, $brand_ids = null, string $contentType = self::contentTypes['listDocuments'][0])
    {
        $request = $this->listDocumentsRequest($page, $sent_by, $recipients, $transmit_type, $page_size, $start_date, $status, $end_date, $search_key, $labels, $next_cursor, $brand_ids, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\BoldSign\Model\DocumentRecords' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\BoldSign\Model\DocumentRecords' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\BoldSign\Model\DocumentRecords', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 401:
                    if ('\BoldSign\Model\ErrorResult' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\BoldSign\Model\ErrorResult' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\BoldSign\Model\ErrorResult', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\BoldSign\Model\DocumentRecords';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BoldSign\Model\DocumentRecords',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BoldSign\Model\ErrorResult',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation listDocumentsAsync
     *
     * List user documents.
     *
     * @param  int $page Page index specified in get document list request. (required)
     * @param  string[] $sent_by (optional)
     * @param  string[] $recipients (optional)
     * @param  string $transmit_type (optional)
     * @param  int $page_size Page size specified in get document list request. (optional, default to 10)
     * @param  \DateTime $start_date Start date of the document (optional)
     * @param  string[] $status Status of the document such as In-progress, Completed, Decline, Expired, Revoked, Draft. (optional)
     * @param  \DateTime $end_date End date of the document (optional)
     * @param  string $search_key Documents can be listed by the search key present in the document like document title, document ID, sender or recipient(s) name, etc., (optional)
     * @param  string[] $labels Labels of the document. (optional)
     * @param  int $next_cursor Next cursor value for pagination, required for fetching the next set of documents beyond 10,000 records. (optional)
     * @param  string[] $brand_ids BrandId(s) of the document. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listDocuments'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listDocumentsAsync($page, $sent_by = null, $recipients = null, $transmit_type = null, $page_size = 10, $start_date = null, $status = null, $end_date = null, $search_key = null, $labels = null, $next_cursor = null, $brand_ids = null, string $contentType = self::contentTypes['listDocuments'][0])
    {
        return $this->listDocumentsAsyncWithHttpInfo($page, $sent_by, $recipients, $transmit_type, $page_size, $start_date, $status, $end_date, $search_key, $labels, $next_cursor, $brand_ids, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listDocumentsAsyncWithHttpInfo
     *
     * List user documents.
     *
     * @param  int $page Page index specified in get document list request. (required)
     * @param  string[] $sent_by (optional)
     * @param  string[] $recipients (optional)
     * @param  string $transmit_type (optional)
     * @param  int $page_size Page size specified in get document list request. (optional, default to 10)
     * @param  \DateTime $start_date Start date of the document (optional)
     * @param  string[] $status Status of the document such as In-progress, Completed, Decline, Expired, Revoked, Draft. (optional)
     * @param  \DateTime $end_date End date of the document (optional)
     * @param  string $search_key Documents can be listed by the search key present in the document like document title, document ID, sender or recipient(s) name, etc., (optional)
     * @param  string[] $labels Labels of the document. (optional)
     * @param  int $next_cursor Next cursor value for pagination, required for fetching the next set of documents beyond 10,000 records. (optional)
     * @param  string[] $brand_ids BrandId(s) of the document. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listDocuments'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listDocumentsAsyncWithHttpInfo($page, $sent_by = null, $recipients = null, $transmit_type = null, $page_size = 10, $start_date = null, $status = null, $end_date = null, $search_key = null, $labels = null, $next_cursor = null, $brand_ids = null, string $contentType = self::contentTypes['listDocuments'][0])
    {
        $returnType = '\BoldSign\Model\DocumentRecords';
        $request = $this->listDocumentsRequest($page, $sent_by, $recipients, $transmit_type, $page_size, $start_date, $status, $end_date, $search_key, $labels, $next_cursor, $brand_ids, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listDocuments'
     *
     * @param  int $page Page index specified in get document list request. (required)
     * @param  string[] $sent_by (optional)
     * @param  string[] $recipients (optional)
     * @param  string $transmit_type (optional)
     * @param  int $page_size Page size specified in get document list request. (optional, default to 10)
     * @param  \DateTime $start_date Start date of the document (optional)
     * @param  string[] $status Status of the document such as In-progress, Completed, Decline, Expired, Revoked, Draft. (optional)
     * @param  \DateTime $end_date End date of the document (optional)
     * @param  string $search_key Documents can be listed by the search key present in the document like document title, document ID, sender or recipient(s) name, etc., (optional)
     * @param  string[] $labels Labels of the document. (optional)
     * @param  int $next_cursor Next cursor value for pagination, required for fetching the next set of documents beyond 10,000 records. (optional)
     * @param  string[] $brand_ids BrandId(s) of the document. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listDocuments'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function listDocumentsRequest($page, $sent_by = null, $recipients = null, $transmit_type = null, $page_size = 10, $start_date = null, $status = null, $end_date = null, $search_key = null, $labels = null, $next_cursor = null, $brand_ids = null, string $contentType = self::contentTypes['listDocuments'][0])
    {

        // verify the required parameter 'page' is set
        if ($page === null || (is_array($page) && count($page) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $page when calling listDocuments'
            );
        }













        $resourcePath = '/v1/document/list';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sent_by,
            'SentBy', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $recipients,
            'Recipients', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $transmit_type,
            'TransmitType', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page_size,
            'PageSize', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page,
            'Page', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $start_date,
            'StartDate', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $status,
            'Status', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $end_date,
            'EndDate', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $search_key,
            'SearchKey', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $labels,
            'Labels', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $next_cursor,
            'NextCursor', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $brand_ids,
            'BrandIds', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            $multipart ? ['multipart/form-data'] : ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                if (!empty($body)) {
                    $multipartContents[] = [
                        'name'     => 'body',
                        'contents' => $body,
                        'headers'  => ['Content-Type' => 'application/json'],
                    ];
                }

                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-KEY');
        if ($apiKey !== null) {
            $headers['X-API-KEY'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation prefillFields
     *
     * Updates the value (prefill) of the fields in the document.
     *
     * @param  string $document_id The DocumentId. (required)
     * @param  \BoldSign\Model\PrefillFieldRequest $prefill_field_request The prefill field request. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['prefillFields'] to see the possible values for this operation
     *
     * @throws \BoldSign\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function prefillFields($document_id, $prefill_field_request, string $contentType = self::contentTypes['prefillFields'][0])
    {
        $this->prefillFieldsWithHttpInfo($document_id, $prefill_field_request, $contentType);
    }

    /**
     * Operation prefillFieldsWithHttpInfo
     *
     * Updates the value (prefill) of the fields in the document.
     *
     * @param  string $document_id The DocumentId. (required)
     * @param  \BoldSign\Model\PrefillFieldRequest $prefill_field_request The prefill field request. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['prefillFields'] to see the possible values for this operation
     *
     * @throws \BoldSign\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function prefillFieldsWithHttpInfo($document_id, $prefill_field_request, string $contentType = self::contentTypes['prefillFields'][0])
    {
        $request = $this->prefillFieldsRequest($document_id, $prefill_field_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BoldSign\Model\ErrorResult',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BoldSign\Model\ErrorResult',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation prefillFieldsAsync
     *
     * Updates the value (prefill) of the fields in the document.
     *
     * @param  string $document_id The DocumentId. (required)
     * @param  \BoldSign\Model\PrefillFieldRequest $prefill_field_request The prefill field request. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['prefillFields'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function prefillFieldsAsync($document_id, $prefill_field_request, string $contentType = self::contentTypes['prefillFields'][0])
    {
        return $this->prefillFieldsAsyncWithHttpInfo($document_id, $prefill_field_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation prefillFieldsAsyncWithHttpInfo
     *
     * Updates the value (prefill) of the fields in the document.
     *
     * @param  string $document_id The DocumentId. (required)
     * @param  \BoldSign\Model\PrefillFieldRequest $prefill_field_request The prefill field request. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['prefillFields'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function prefillFieldsAsyncWithHttpInfo($document_id, $prefill_field_request, string $contentType = self::contentTypes['prefillFields'][0])
    {
        $returnType = '';
        $request = $this->prefillFieldsRequest($document_id, $prefill_field_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'prefillFields'
     *
     * @param  string $document_id The DocumentId. (required)
     * @param  \BoldSign\Model\PrefillFieldRequest $prefill_field_request The prefill field request. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['prefillFields'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function prefillFieldsRequest($document_id, $prefill_field_request, string $contentType = self::contentTypes['prefillFields'][0])
    {

        // verify the required parameter 'document_id' is set
        if ($document_id === null || (is_array($document_id) && count($document_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $document_id when calling prefillFields'
            );
        }

        // verify the required parameter 'prefill_field_request' is set
        if ($prefill_field_request === null || (is_array($prefill_field_request) && count($prefill_field_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $prefill_field_request when calling prefillFields'
            );
        }


        $resourcePath = '/v1/document/prefillFields';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        if(!is_array($prefill_field_request)) {
            $formParams = ObjectSerializer::getFormParams(
                $prefill_field_request
            );
        }
        else {
            foreach($prefill_field_request as $param){
                $formParams = ObjectSerializer::getFormParams(
                $param);
            }
        }

        $multipart = !empty($formParams);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $document_id,
            'documentId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            $multipart ? ['multipart/form-data'] : ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) === 0) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($prefill_field_request));
            } else {
                $httpBody = $prefill_field_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                if (!empty($body)) {
                    $multipartContents[] = [
                        'name'     => 'body',
                        'contents' => $body,
                        'headers'  => ['Content-Type' => 'application/json'],
                    ];
                }

                if ($payloadHook = $this->config->getPayloadHook()) {
                    $payloadHook('multipart', $multipartContents, $prefill_field_request);
                }
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-KEY');
        if ($apiKey !== null) {
            $headers['X-API-KEY'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PATCH',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation remindDocument
     *
     * Send reminder to pending signers.
     *
     * @param  string $document_id Document Id. (required)
     * @param  string[] $receiver_emails Signer emails. (optional)
     * @param  \BoldSign\Model\ReminderMessage $reminder_message Reminder Message for signers. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['remindDocument'] to see the possible values for this operation
     *
     * @throws \BoldSign\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function remindDocument($document_id, $receiver_emails = null, $reminder_message = null, string $contentType = self::contentTypes['remindDocument'][0])
    {
        $this->remindDocumentWithHttpInfo($document_id, $receiver_emails, $reminder_message, $contentType);
    }

    /**
     * Operation remindDocumentWithHttpInfo
     *
     * Send reminder to pending signers.
     *
     * @param  string $document_id Document Id. (required)
     * @param  string[] $receiver_emails Signer emails. (optional)
     * @param  \BoldSign\Model\ReminderMessage $reminder_message Reminder Message for signers. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['remindDocument'] to see the possible values for this operation
     *
     * @throws \BoldSign\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function remindDocumentWithHttpInfo($document_id, $receiver_emails = null, $reminder_message = null, string $contentType = self::contentTypes['remindDocument'][0])
    {
        $request = $this->remindDocumentRequest($document_id, $receiver_emails, $reminder_message, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BoldSign\Model\ErrorResult',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BoldSign\Model\ErrorResult',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation remindDocumentAsync
     *
     * Send reminder to pending signers.
     *
     * @param  string $document_id Document Id. (required)
     * @param  string[] $receiver_emails Signer emails. (optional)
     * @param  \BoldSign\Model\ReminderMessage $reminder_message Reminder Message for signers. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['remindDocument'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function remindDocumentAsync($document_id, $receiver_emails = null, $reminder_message = null, string $contentType = self::contentTypes['remindDocument'][0])
    {
        return $this->remindDocumentAsyncWithHttpInfo($document_id, $receiver_emails, $reminder_message, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation remindDocumentAsyncWithHttpInfo
     *
     * Send reminder to pending signers.
     *
     * @param  string $document_id Document Id. (required)
     * @param  string[] $receiver_emails Signer emails. (optional)
     * @param  \BoldSign\Model\ReminderMessage $reminder_message Reminder Message for signers. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['remindDocument'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function remindDocumentAsyncWithHttpInfo($document_id, $receiver_emails = null, $reminder_message = null, string $contentType = self::contentTypes['remindDocument'][0])
    {
        $returnType = '';
        $request = $this->remindDocumentRequest($document_id, $receiver_emails, $reminder_message, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'remindDocument'
     *
     * @param  string $document_id Document Id. (required)
     * @param  string[] $receiver_emails Signer emails. (optional)
     * @param  \BoldSign\Model\ReminderMessage $reminder_message Reminder Message for signers. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['remindDocument'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function remindDocumentRequest($document_id, $receiver_emails = null, $reminder_message = null, string $contentType = self::contentTypes['remindDocument'][0])
    {

        // verify the required parameter 'document_id' is set
        if ($document_id === null || (is_array($document_id) && count($document_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $document_id when calling remindDocument'
            );
        }




        $resourcePath = '/v1/document/remind';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        if(!is_array($reminder_message)) {
            $formParams = ObjectSerializer::getFormParams(
                $reminder_message
            );
        }
        else {
            foreach($reminder_message as $param){
                $formParams = ObjectSerializer::getFormParams(
                $param);
            }
        }

        $multipart = !empty($formParams);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $document_id,
            'documentId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $receiver_emails,
            'receiverEmails', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            $multipart ? ['multipart/form-data'] : ['application/json;odata.metadata=minimal;odata.streaming=true', 'application/json;odata.metadata=minimal;odata.streaming=false', 'application/json;odata.metadata=minimal', 'application/json;odata.metadata=full;odata.streaming=true', 'application/json;odata.metadata=full;odata.streaming=false', 'application/json;odata.metadata=full', 'application/json;odata.metadata=none;odata.streaming=true', 'application/json;odata.metadata=none;odata.streaming=false', 'application/json;odata.metadata=none', 'application/json;odata.streaming=true', 'application/json;odata.streaming=false', 'application/json', 'application/xml', 'application/prs.odatatestxx-odata', 'text/plain', 'text/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) === 0) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($reminder_message));
            } else {
                $httpBody = $reminder_message;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                if (!empty($body)) {
                    $multipartContents[] = [
                        'name'     => 'body',
                        'contents' => $body,
                        'headers'  => ['Content-Type' => 'application/json'],
                    ];
                }

                if ($payloadHook = $this->config->getPayloadHook()) {
                    $payloadHook('multipart', $multipartContents, $reminder_message);
                }
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-KEY');
        if ($apiKey !== null) {
            $headers['X-API-KEY'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation removeAuthentication
     *
     * Remove the access code for the given document signer.
     *
     * @param  string $document_id Document ID of the signature request (required)
     * @param  \BoldSign\Model\RemoveAuthentication $remove_authentication To remove access code. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['removeAuthentication'] to see the possible values for this operation
     *
     * @throws \BoldSign\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function removeAuthentication($document_id, $remove_authentication = null, string $contentType = self::contentTypes['removeAuthentication'][0])
    {
        $this->removeAuthenticationWithHttpInfo($document_id, $remove_authentication, $contentType);
    }

    /**
     * Operation removeAuthenticationWithHttpInfo
     *
     * Remove the access code for the given document signer.
     *
     * @param  string $document_id Document ID of the signature request (required)
     * @param  \BoldSign\Model\RemoveAuthentication $remove_authentication To remove access code. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['removeAuthentication'] to see the possible values for this operation
     *
     * @throws \BoldSign\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function removeAuthenticationWithHttpInfo($document_id, $remove_authentication = null, string $contentType = self::contentTypes['removeAuthentication'][0])
    {
        $request = $this->removeAuthenticationRequest($document_id, $remove_authentication, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BoldSign\Model\ErrorResult',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BoldSign\Model\ErrorResult',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation removeAuthenticationAsync
     *
     * Remove the access code for the given document signer.
     *
     * @param  string $document_id Document ID of the signature request (required)
     * @param  \BoldSign\Model\RemoveAuthentication $remove_authentication To remove access code. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['removeAuthentication'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function removeAuthenticationAsync($document_id, $remove_authentication = null, string $contentType = self::contentTypes['removeAuthentication'][0])
    {
        return $this->removeAuthenticationAsyncWithHttpInfo($document_id, $remove_authentication, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation removeAuthenticationAsyncWithHttpInfo
     *
     * Remove the access code for the given document signer.
     *
     * @param  string $document_id Document ID of the signature request (required)
     * @param  \BoldSign\Model\RemoveAuthentication $remove_authentication To remove access code. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['removeAuthentication'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function removeAuthenticationAsyncWithHttpInfo($document_id, $remove_authentication = null, string $contentType = self::contentTypes['removeAuthentication'][0])
    {
        $returnType = '';
        $request = $this->removeAuthenticationRequest($document_id, $remove_authentication, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'removeAuthentication'
     *
     * @param  string $document_id Document ID of the signature request (required)
     * @param  \BoldSign\Model\RemoveAuthentication $remove_authentication To remove access code. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['removeAuthentication'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function removeAuthenticationRequest($document_id, $remove_authentication = null, string $contentType = self::contentTypes['removeAuthentication'][0])
    {

        // verify the required parameter 'document_id' is set
        if ($document_id === null || (is_array($document_id) && count($document_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $document_id when calling removeAuthentication'
            );
        }



        $resourcePath = '/v1/document/RemoveAuthentication';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        if(!is_array($remove_authentication)) {
            $formParams = ObjectSerializer::getFormParams(
                $remove_authentication
            );
        }
        else {
            foreach($remove_authentication as $param){
                $formParams = ObjectSerializer::getFormParams(
                $param);
            }
        }

        $multipart = !empty($formParams);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $document_id,
            'DocumentId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            $multipart ? ['multipart/form-data'] : ['application/json;odata.metadata=minimal;odata.streaming=true', 'application/json;odata.metadata=minimal;odata.streaming=false', 'application/json;odata.metadata=minimal', 'application/json;odata.metadata=full;odata.streaming=true', 'application/json;odata.metadata=full;odata.streaming=false', 'application/json;odata.metadata=full', 'application/json;odata.metadata=none;odata.streaming=true', 'application/json;odata.metadata=none;odata.streaming=false', 'application/json;odata.metadata=none', 'application/json;odata.streaming=true', 'application/json;odata.streaming=false', 'application/json', 'application/xml', 'application/prs.odatatestxx-odata', 'text/plain', 'text/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) === 0) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($remove_authentication));
            } else {
                $httpBody = $remove_authentication;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                if (!empty($body)) {
                    $multipartContents[] = [
                        'name'     => 'body',
                        'contents' => $body,
                        'headers'  => ['Content-Type' => 'application/json'],
                    ];
                }

                if ($payloadHook = $this->config->getPayloadHook()) {
                    $payloadHook('multipart', $multipartContents, $remove_authentication);
                }
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-KEY');
        if ($apiKey !== null) {
            $headers['X-API-KEY'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PATCH',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation revokeDocument
     *
     * Revoke the document.
     *
     * @param  string $document_id Document Id. (required)
     * @param  \BoldSign\Model\RevokeDocument $revoke_document RevokeDetails. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['revokeDocument'] to see the possible values for this operation
     *
     * @throws \BoldSign\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function revokeDocument($document_id, $revoke_document, string $contentType = self::contentTypes['revokeDocument'][0])
    {
        $this->revokeDocumentWithHttpInfo($document_id, $revoke_document, $contentType);
    }

    /**
     * Operation revokeDocumentWithHttpInfo
     *
     * Revoke the document.
     *
     * @param  string $document_id Document Id. (required)
     * @param  \BoldSign\Model\RevokeDocument $revoke_document RevokeDetails. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['revokeDocument'] to see the possible values for this operation
     *
     * @throws \BoldSign\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function revokeDocumentWithHttpInfo($document_id, $revoke_document, string $contentType = self::contentTypes['revokeDocument'][0])
    {
        $request = $this->revokeDocumentRequest($document_id, $revoke_document, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BoldSign\Model\ErrorResult',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BoldSign\Model\ErrorResult',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation revokeDocumentAsync
     *
     * Revoke the document.
     *
     * @param  string $document_id Document Id. (required)
     * @param  \BoldSign\Model\RevokeDocument $revoke_document RevokeDetails. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['revokeDocument'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function revokeDocumentAsync($document_id, $revoke_document, string $contentType = self::contentTypes['revokeDocument'][0])
    {
        return $this->revokeDocumentAsyncWithHttpInfo($document_id, $revoke_document, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation revokeDocumentAsyncWithHttpInfo
     *
     * Revoke the document.
     *
     * @param  string $document_id Document Id. (required)
     * @param  \BoldSign\Model\RevokeDocument $revoke_document RevokeDetails. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['revokeDocument'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function revokeDocumentAsyncWithHttpInfo($document_id, $revoke_document, string $contentType = self::contentTypes['revokeDocument'][0])
    {
        $returnType = '';
        $request = $this->revokeDocumentRequest($document_id, $revoke_document, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'revokeDocument'
     *
     * @param  string $document_id Document Id. (required)
     * @param  \BoldSign\Model\RevokeDocument $revoke_document RevokeDetails. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['revokeDocument'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function revokeDocumentRequest($document_id, $revoke_document, string $contentType = self::contentTypes['revokeDocument'][0])
    {

        // verify the required parameter 'document_id' is set
        if ($document_id === null || (is_array($document_id) && count($document_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $document_id when calling revokeDocument'
            );
        }

        // verify the required parameter 'revoke_document' is set
        if ($revoke_document === null || (is_array($revoke_document) && count($revoke_document) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $revoke_document when calling revokeDocument'
            );
        }


        $resourcePath = '/v1/document/revoke';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        if(!is_array($revoke_document)) {
            $formParams = ObjectSerializer::getFormParams(
                $revoke_document
            );
        }
        else {
            foreach($revoke_document as $param){
                $formParams = ObjectSerializer::getFormParams(
                $param);
            }
        }

        $multipart = !empty($formParams);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $document_id,
            'documentId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            $multipart ? ['multipart/form-data'] : ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) === 0) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($revoke_document));
            } else {
                $httpBody = $revoke_document;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                if (!empty($body)) {
                    $multipartContents[] = [
                        'name'     => 'body',
                        'contents' => $body,
                        'headers'  => ['Content-Type' => 'application/json'],
                    ];
                }

                if ($payloadHook = $this->config->getPayloadHook()) {
                    $payloadHook('multipart', $multipartContents, $revoke_document);
                }
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-KEY');
        if ($apiKey !== null) {
            $headers['X-API-KEY'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation sendDocument
     *
     * Sends the document for sign.
     *
     * @param  \BoldSign\Model\SendForSign $send_for_sign The send for sign request body. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['sendDocument'] to see the possible values for this operation
     *
     * @throws \BoldSign\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \BoldSign\Model\DocumentCreated|\BoldSign\Model\ErrorResult|\BoldSign\Model\ErrorResult
     */
    public function sendDocument($send_for_sign = null, string $contentType = self::contentTypes['sendDocument'][0])
    {
        list($response) = $this->sendDocumentWithHttpInfo($send_for_sign, $contentType);
        return $response;
    }

    /**
     * Operation sendDocumentWithHttpInfo
     *
     * Sends the document for sign.
     *
     * @param  \BoldSign\Model\SendForSign $send_for_sign The send for sign request body. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['sendDocument'] to see the possible values for this operation
     *
     * @throws \BoldSign\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \BoldSign\Model\DocumentCreated|\BoldSign\Model\ErrorResult|\BoldSign\Model\ErrorResult, HTTP status code, HTTP response headers (array of strings)
     */
    public function sendDocumentWithHttpInfo($send_for_sign = null, string $contentType = self::contentTypes['sendDocument'][0])
    {
        $request = $this->sendDocumentRequest($send_for_sign, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 201:
                    if ('\BoldSign\Model\DocumentCreated' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\BoldSign\Model\DocumentCreated' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\BoldSign\Model\DocumentCreated', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 401:
                    if ('\BoldSign\Model\ErrorResult' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\BoldSign\Model\ErrorResult' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\BoldSign\Model\ErrorResult', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 403:
                    if ('\BoldSign\Model\ErrorResult' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\BoldSign\Model\ErrorResult' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\BoldSign\Model\ErrorResult', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\BoldSign\Model\DocumentCreated';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BoldSign\Model\DocumentCreated',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BoldSign\Model\ErrorResult',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BoldSign\Model\ErrorResult',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation sendDocumentAsync
     *
     * Sends the document for sign.
     *
     * @param  \BoldSign\Model\SendForSign $send_for_sign The send for sign request body. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['sendDocument'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function sendDocumentAsync($send_for_sign = null, string $contentType = self::contentTypes['sendDocument'][0])
    {
        return $this->sendDocumentAsyncWithHttpInfo($send_for_sign, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation sendDocumentAsyncWithHttpInfo
     *
     * Sends the document for sign.
     *
     * @param  \BoldSign\Model\SendForSign $send_for_sign The send for sign request body. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['sendDocument'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function sendDocumentAsyncWithHttpInfo($send_for_sign = null, string $contentType = self::contentTypes['sendDocument'][0])
    {
        $returnType = '\BoldSign\Model\DocumentCreated';
        $request = $this->sendDocumentRequest($send_for_sign, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'sendDocument'
     *
     * @param  \BoldSign\Model\SendForSign $send_for_sign The send for sign request body. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['sendDocument'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function sendDocumentRequest($send_for_sign = null, string $contentType = self::contentTypes['sendDocument'][0])
    {



        $resourcePath = '/v1/document/send';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        if(!is_array($send_for_sign)) {
            $formParams = ObjectSerializer::getFormParams(
                $send_for_sign
            );
        }
        else {
            foreach($send_for_sign as $param){
                $formParams = ObjectSerializer::getFormParams(
                $param);
            }
        }

        $multipart = !empty($formParams);




        $headers = $this->headerSelector->selectHeaders(
            $multipart ? ['multipart/form-data'] : ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) === 0) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($send_for_sign));
            } else {
                $httpBody = $send_for_sign;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                if (!empty($body)) {
                    $multipartContents[] = [
                        'name'     => 'body',
                        'contents' => $body,
                        'headers'  => ['Content-Type' => 'application/json'],
                    ];
                }

                if ($payloadHook = $this->config->getPayloadHook()) {
                    $payloadHook('multipart', $multipartContents, $send_for_sign);
                }
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-KEY');
        if ($apiKey !== null) {
            $headers['X-API-KEY'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation teamDocuments
     *
     * Get user Team documents.
     *
     * @param  int $page Page index specified in get document list request. (required)
     * @param  string[] $user_id UserId of the  Team document. (optional)
     * @param  string[] $team_id TeamId  of the  Team document. (optional)
     * @param  string $transmit_type Transmit type as Sent, Received and Both. (optional)
     * @param  int $page_size Page size specified in get document list request. (optional, default to 10)
     * @param  \DateTime $start_date Start date of the document (optional)
     * @param  string[] $status Status of the document such as In-progress, Completed, Decline, Expired, Revoked, Draft. (optional)
     * @param  \DateTime $end_date End date of the document (optional)
     * @param  string $search_key Documents can be listed by the search key present in the document like document title, document ID, sender or recipient(s) name, etc., (optional)
     * @param  string[] $labels Labels of the document. (optional)
     * @param  int $next_cursor Next cursor value for pagination, required for fetching the next set of documents beyond 10,000 records. (optional)
     * @param  string[] $brand_ids BrandId(s) of the document. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamDocuments'] to see the possible values for this operation
     *
     * @throws \BoldSign\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \BoldSign\Model\TeamDocumentRecords|\BoldSign\Model\ErrorResult|\BoldSign\Model\ErrorResult
     */
    public function teamDocuments($page, $user_id = null, $team_id = null, $transmit_type = null, $page_size = 10, $start_date = null, $status = null, $end_date = null, $search_key = null, $labels = null, $next_cursor = null, $brand_ids = null, string $contentType = self::contentTypes['teamDocuments'][0])
    {
        list($response) = $this->teamDocumentsWithHttpInfo($page, $user_id, $team_id, $transmit_type, $page_size, $start_date, $status, $end_date, $search_key, $labels, $next_cursor, $brand_ids, $contentType);
        return $response;
    }

    /**
     * Operation teamDocumentsWithHttpInfo
     *
     * Get user Team documents.
     *
     * @param  int $page Page index specified in get document list request. (required)
     * @param  string[] $user_id UserId of the  Team document. (optional)
     * @param  string[] $team_id TeamId  of the  Team document. (optional)
     * @param  string $transmit_type Transmit type as Sent, Received and Both. (optional)
     * @param  int $page_size Page size specified in get document list request. (optional, default to 10)
     * @param  \DateTime $start_date Start date of the document (optional)
     * @param  string[] $status Status of the document such as In-progress, Completed, Decline, Expired, Revoked, Draft. (optional)
     * @param  \DateTime $end_date End date of the document (optional)
     * @param  string $search_key Documents can be listed by the search key present in the document like document title, document ID, sender or recipient(s) name, etc., (optional)
     * @param  string[] $labels Labels of the document. (optional)
     * @param  int $next_cursor Next cursor value for pagination, required for fetching the next set of documents beyond 10,000 records. (optional)
     * @param  string[] $brand_ids BrandId(s) of the document. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamDocuments'] to see the possible values for this operation
     *
     * @throws \BoldSign\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \BoldSign\Model\TeamDocumentRecords|\BoldSign\Model\ErrorResult|\BoldSign\Model\ErrorResult, HTTP status code, HTTP response headers (array of strings)
     */
    public function teamDocumentsWithHttpInfo($page, $user_id = null, $team_id = null, $transmit_type = null, $page_size = 10, $start_date = null, $status = null, $end_date = null, $search_key = null, $labels = null, $next_cursor = null, $brand_ids = null, string $contentType = self::contentTypes['teamDocuments'][0])
    {
        $request = $this->teamDocumentsRequest($page, $user_id, $team_id, $transmit_type, $page_size, $start_date, $status, $end_date, $search_key, $labels, $next_cursor, $brand_ids, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\BoldSign\Model\TeamDocumentRecords' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\BoldSign\Model\TeamDocumentRecords' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\BoldSign\Model\TeamDocumentRecords', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 401:
                    if ('\BoldSign\Model\ErrorResult' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\BoldSign\Model\ErrorResult' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\BoldSign\Model\ErrorResult', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 403:
                    if ('\BoldSign\Model\ErrorResult' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\BoldSign\Model\ErrorResult' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\BoldSign\Model\ErrorResult', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\BoldSign\Model\TeamDocumentRecords';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BoldSign\Model\TeamDocumentRecords',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BoldSign\Model\ErrorResult',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BoldSign\Model\ErrorResult',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation teamDocumentsAsync
     *
     * Get user Team documents.
     *
     * @param  int $page Page index specified in get document list request. (required)
     * @param  string[] $user_id UserId of the  Team document. (optional)
     * @param  string[] $team_id TeamId  of the  Team document. (optional)
     * @param  string $transmit_type Transmit type as Sent, Received and Both. (optional)
     * @param  int $page_size Page size specified in get document list request. (optional, default to 10)
     * @param  \DateTime $start_date Start date of the document (optional)
     * @param  string[] $status Status of the document such as In-progress, Completed, Decline, Expired, Revoked, Draft. (optional)
     * @param  \DateTime $end_date End date of the document (optional)
     * @param  string $search_key Documents can be listed by the search key present in the document like document title, document ID, sender or recipient(s) name, etc., (optional)
     * @param  string[] $labels Labels of the document. (optional)
     * @param  int $next_cursor Next cursor value for pagination, required for fetching the next set of documents beyond 10,000 records. (optional)
     * @param  string[] $brand_ids BrandId(s) of the document. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamDocuments'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function teamDocumentsAsync($page, $user_id = null, $team_id = null, $transmit_type = null, $page_size = 10, $start_date = null, $status = null, $end_date = null, $search_key = null, $labels = null, $next_cursor = null, $brand_ids = null, string $contentType = self::contentTypes['teamDocuments'][0])
    {
        return $this->teamDocumentsAsyncWithHttpInfo($page, $user_id, $team_id, $transmit_type, $page_size, $start_date, $status, $end_date, $search_key, $labels, $next_cursor, $brand_ids, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation teamDocumentsAsyncWithHttpInfo
     *
     * Get user Team documents.
     *
     * @param  int $page Page index specified in get document list request. (required)
     * @param  string[] $user_id UserId of the  Team document. (optional)
     * @param  string[] $team_id TeamId  of the  Team document. (optional)
     * @param  string $transmit_type Transmit type as Sent, Received and Both. (optional)
     * @param  int $page_size Page size specified in get document list request. (optional, default to 10)
     * @param  \DateTime $start_date Start date of the document (optional)
     * @param  string[] $status Status of the document such as In-progress, Completed, Decline, Expired, Revoked, Draft. (optional)
     * @param  \DateTime $end_date End date of the document (optional)
     * @param  string $search_key Documents can be listed by the search key present in the document like document title, document ID, sender or recipient(s) name, etc., (optional)
     * @param  string[] $labels Labels of the document. (optional)
     * @param  int $next_cursor Next cursor value for pagination, required for fetching the next set of documents beyond 10,000 records. (optional)
     * @param  string[] $brand_ids BrandId(s) of the document. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamDocuments'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function teamDocumentsAsyncWithHttpInfo($page, $user_id = null, $team_id = null, $transmit_type = null, $page_size = 10, $start_date = null, $status = null, $end_date = null, $search_key = null, $labels = null, $next_cursor = null, $brand_ids = null, string $contentType = self::contentTypes['teamDocuments'][0])
    {
        $returnType = '\BoldSign\Model\TeamDocumentRecords';
        $request = $this->teamDocumentsRequest($page, $user_id, $team_id, $transmit_type, $page_size, $start_date, $status, $end_date, $search_key, $labels, $next_cursor, $brand_ids, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'teamDocuments'
     *
     * @param  int $page Page index specified in get document list request. (required)
     * @param  string[] $user_id UserId of the  Team document. (optional)
     * @param  string[] $team_id TeamId  of the  Team document. (optional)
     * @param  string $transmit_type Transmit type as Sent, Received and Both. (optional)
     * @param  int $page_size Page size specified in get document list request. (optional, default to 10)
     * @param  \DateTime $start_date Start date of the document (optional)
     * @param  string[] $status Status of the document such as In-progress, Completed, Decline, Expired, Revoked, Draft. (optional)
     * @param  \DateTime $end_date End date of the document (optional)
     * @param  string $search_key Documents can be listed by the search key present in the document like document title, document ID, sender or recipient(s) name, etc., (optional)
     * @param  string[] $labels Labels of the document. (optional)
     * @param  int $next_cursor Next cursor value for pagination, required for fetching the next set of documents beyond 10,000 records. (optional)
     * @param  string[] $brand_ids BrandId(s) of the document. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamDocuments'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function teamDocumentsRequest($page, $user_id = null, $team_id = null, $transmit_type = null, $page_size = 10, $start_date = null, $status = null, $end_date = null, $search_key = null, $labels = null, $next_cursor = null, $brand_ids = null, string $contentType = self::contentTypes['teamDocuments'][0])
    {

        // verify the required parameter 'page' is set
        if ($page === null || (is_array($page) && count($page) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $page when calling teamDocuments'
            );
        }













        $resourcePath = '/v1/document/teamlist';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $user_id,
            'UserId', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $team_id,
            'TeamId', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $transmit_type,
            'TransmitType', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page_size,
            'PageSize', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page,
            'Page', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $start_date,
            'StartDate', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $status,
            'Status', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $end_date,
            'EndDate', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $search_key,
            'SearchKey', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $labels,
            'Labels', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $next_cursor,
            'NextCursor', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $brand_ids,
            'BrandIds', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            $multipart ? ['multipart/form-data'] : ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                if (!empty($body)) {
                    $multipartContents[] = [
                        'name'     => 'body',
                        'contents' => $body,
                        'headers'  => ['Content-Type' => 'application/json'],
                    ];
                }

                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-KEY');
        if ($apiKey !== null) {
            $headers['X-API-KEY'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
